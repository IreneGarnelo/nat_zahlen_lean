{"name": "Die nat\u00fcrlichen Zahlen", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Die nat\u00fcrlichen Zahlen-1.0-library.zip", "introData": {"name": "1", "problemIndex": -1, "objects": [{"type": "text", "content": "2"}]}, "worlds": [{"name": "3", "levels": [{"name": "4", "problemIndex": 8, "objects": [{"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": true}, {"type": "lean", "content": "7", "hidden": true}, {"type": "text", "content": "8"}, {"type": "hint", "content": "9", "title": "10"}, {"type": "text", "content": "11"}, {"type": "hint", "content": "12", "title": "13"}, {"type": "text", "content": "14"}, {"type": "theorem", "text": "15", "lean": "theorem succ_succ (a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\n", "sideBar": true, "firstProofLineNumber": 84, "lastProofLineNumber": 87, "textBefore": "-- Level name : Die Peano Axiome\n\n-- namespace nat -- hide \n\nimport natnum.definition -- hide\nnamespace N -- hide\n\n/-\nDie nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN: `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N}$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\nIn LEAN kann man die Anwendung der Abbildung `succ` auf `a` sowohl als `succ(a)` als auch \nals `a.succ` schreiben.\n-/\n\n/- Hint : Wieso brauchen wir hier die Abbildung `succ`, um den Nachfolger einer Zahl $n$ zu beschreiben, anstatt den Ausdruck n+1 zu verwenden?\nWir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n-/\n\n/-\nAus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen uns nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nN arbeiten, die genau nach den Axiomen von Peano definiert ist.\n-/\n\n/- Hint : Klicke hier, um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`inductive N` \u2192 $A_4$ <br>\n`| zero : N` \u2192 $A_1$ <br>\n`| succ (n : N) : N` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : N} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : N) : (zero : N) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n-/\n\n/-\nAls Erstes muss man das Lemma definieren, das man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`.\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein Keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses Keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinweisen, dass noch etwas zu tun ist. L\u00f6sche als\nErstes das `sorry`, um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehl. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehst, \u00fcberpr\u00fcfe deinen Code auf fehlende Kommata.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisches Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das, was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen.\n-/\n\n/- Theorem\nFalls `succ`$(a) = b$, dann `succ`$($`succ`$(a)) = $`succ`$(b)$\n-/\ntheorem succ_succ (a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\nbegin\n", "proof": "rw h,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\n\nend N -- hide", "height": 4, "editorText": "sorry", "lineOffset": 83, "name": "succ_succ", "statement": "(a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b)"}, {"type": "tactic", "content": "16", "name": "rw", "sideBar": true}, {"type": "lean", "content": "17", "hidden": true}]}, {"name": "18", "problemIndex": 5, "objects": [{"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "lean", "content": "21", "hidden": true}, {"type": "lean", "content": "22", "hidden": true}, {"type": "text", "content": "23"}, {"type": "theorem", "text": "24", "lean": "theorem succ_succ_c (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 40, "textBefore": "-- Level name : Die Peano Axiome - Teil 2\n\n-- namespace nat -- hide \n\nimport natnum.definition -- hide\nimport game.Peano.level_1 --hide\nnamespace N -- hide\n\n/-\nIn diesem Level passiert nicht viel. Es dient eher zur \u00dcbung von dem Gelernten in\nLevel 1.\n\nVielleicht hast du gemerkt, dass es eine linke Spalte gibt. Hier kannst du alle\nTools finden, die du zum Beweisen brauchst. Das sind einerseits die Befehle (wie\nz.B. `rw`), die in LEAN Tactics hei\u00dfen. Andererseits sind das die Axiome und Aussagen,\ndie wir bereits eingef\u00fchrt/bewiesen haben. Diese sind in der Kategorie Theorem\nstatements. Umso weiter du bist, umso mehr Inhalt wirst du hier finden.\n\nWir werden aber auch die Gelegenheit nutzen, um uns den `rw` Befehl nochmal\nanzuschauen. Wir haben gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetzt. Aber wie\nkann man jedes `b` durch ein `a` ersetzen? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg?\n-/\n\n/- Theorem\nFalls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$\n-/\ntheorem succ_succ_c (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\nbegin\n", "proof": "rw h,\nrw g,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint : Brauchst du Hilfe, um einen zweiten Weg zu finden?\nIn der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 35, "name": "succ_succ_c", "statement": "(a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c"}, {"type": "lean", "content": "25", "hidden": true}, {"type": "hint", "content": "26", "title": "27"}]}]}, {"name": "28", "levels": [{"name": "29", "problemIndex": 8, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "axiom", "content": "33", "name": "add_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "34", "name": "add_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "35"}, {"type": "hint", "content": "36", "title": "37"}, {"type": "text", "content": "38"}, {"type": "theorem", "text": "39", "lean": "theorem add_succ_zero (a : N) : a + succ(zero) = succ(a) :=\n", "sideBar": true, "firstProofLineNumber": 52, "lastProofLineNumber": 56, "textBefore": "-- Level name : Die Addition\n\nimport natnum.add -- hide\nimport game.Peano.level_2 --hide\nnamespace N -- hide\n\n/- Axiom : add_zero (a : N) :\na + 0 = a\n-/\n\n/- Axiom : add_succ (a b : N) :\na + succ(b) = succ(a + b)\n-/\n\n\n/-\nMan kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n-/\n\n/- Hint : Klicke hier, um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def add : N \u2192 N \u2192 N` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : N) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : N) : m + succ n = succ (m + n) := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\n-/\n\n/- Theorem\n$a+$`succ`$(0)=$`succ`$(a)$\n-/\ntheorem add_succ_zero (a : N) : a + succ(zero) = succ(a) :=\nbegin\n", "proof": "  rw add_succ,\n  rw add_zero,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 5, "editorText": "sorry", "lineOffset": 51, "name": "add_succ_zero", "statement": "(a : N) : a + succ(zero) = succ(a)"}, {"type": "lean", "content": "40", "hidden": true}]}, {"name": "41", "problemIndex": 7, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "lean", "content": "43", "hidden": true}, {"type": "lean", "content": "44", "hidden": true}, {"type": "axiom", "content": "45", "name": "one_eq_succ_zero (a : N) :", "sideBar": true}, {"type": "text", "content": "46"}, {"type": "hint", "content": "47", "title": "48"}, {"type": "text", "content": "49"}, {"type": "theorem", "text": "50", "lean": "theorem succ_eq_add_one (a : N) : succ(a) = a + one :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 36, "textBefore": "-- Level name : Die nat\u00fcrliche Zahl 1\n\nimport natnum.add -- hide\nimport game.Addition.level_1 --hide\nnamespace N -- hide\n\n/- Axiom : one_eq_succ_zero (a : N) :\none = succ(zero)\n-/\n\n/-\nAus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`def one : N := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n-/\n\n/- \nNun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. \n-/\n\n/- Theorem\n`succ`$(a) = a + 1$\n-/\ntheorem succ_eq_add_one (a : N) : succ(a) = a + one :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw add_succ,\nrw add_zero,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 30, "name": "succ_eq_add_one", "statement": "(a : N) : succ(a) = a + one"}, {"type": "lean", "content": "51", "hidden": true}]}, {"name": "52", "problemIndex": 5, "objects": [{"type": "lean", "content": "53", "hidden": true}, {"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "tactic", "content": "56", "name": "induction", "sideBar": true}, {"type": "text", "content": "57"}, {"type": "theorem", "text": "58", "lean": "theorem zero_add (a : N) : zero + a = a :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 68, "textBefore": "-- Level name : Addition mit 0 - von links\n\nimport natnum.add -- hide\nimport game.Addition.level_2 --hide\nnamespace N -- hide\n\n/- Tactic : induction\n## Anleitung\nfalls `n : N` gegeben ist, dann startet `induction n with d hd`\neinen Induktionsbeweis \u00fcber `n` der zu beweisenden Aussage. `d` wird \nder Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n## Beispiel\nBei folgendem Zustand:\n```\nn : N\n\u22a2 2 * n = n + n\n```\ndann wird `induction n with d hd` zwei neue Ziele \u00f6ffnen:\n```\n\u22a2 2 * 0 = 0 + 0\n```\nund\n```\nd : mynat,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n-/\n\n/-\nNach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir den `induction` Befehl in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\naufrufen. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_3\" target=\"blank\">hier</a> ein Aufgabenblatt.\n-/\n\n/- Theorem\n$0+a=a$\n-/\ntheorem zero_add (a : N) : zero + a = a :=\nbegin\n", "proof": "  induction a with d hd,\n  {rw add_zero,},\n  {rw add_succ,\n  rw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 7, "editorText": "sorry", "lineOffset": 61, "name": "zero_add", "statement": "(a : N) : zero + a = a"}, {"type": "lean", "content": "59", "hidden": true}]}, {"name": "60", "problemIndex": 6, "objects": [{"type": "lean", "content": "61", "hidden": true}, {"type": "lean", "content": "62", "hidden": true}, {"type": "lean", "content": "63", "hidden": true}, {"type": "text", "content": "64"}, {"type": "hint", "content": "65", "title": "66"}, {"type": "text", "content": "67"}, {"type": "theorem", "text": "68", "lean": "theorem add_assoz (a b c : N) : (a + b) + c = a + (b + c) :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 39, "textBefore": "-- Level name : Assoziativit\u00e4t der Addition\n\nimport natnum.add -- hide\nimport game.Addition.level_3 --hide\nnamespace N -- hide\n\n/-\nNun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. \n-/\n\n/- Hint : \u00dcber welcher der drei Variablen ist ein Induktionsbeweis am sinnvollsten?\nWir haben die Addition mit Rekursion auf die rechte Variable definiert,\nes ist also sinnvoll bei dem Induktionsbeweis \u00fcber die Variable\n$c$ zu induzieren.\n-/\n\n/-\nNoch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_4\" target=\"blank\">hier</a> ein Aufgabenblatt.\n-/\n\n/- Theorem\n$(a + b) + c = a + (b + c)$\n-/\ntheorem add_assoz (a b c : N) : (a + b) + c = a + (b + c) :=\nbegin\n", "proof": "  induction c with d hd,\n  {rw add_zero,\n  rw add_zero,},\n  {rw add_succ (a+b) d,\n  rw add_succ,\n  rw add_succ,\n  rw hd,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 10, "editorText": "sorry", "lineOffset": 29, "name": "add_assoz", "statement": "(a b c : N) : (a + b) + c = a + (b + c)"}, {"type": "lean", "content": "69", "hidden": true}]}, {"name": "70", "problemIndex": 4, "objects": [{"type": "lean", "content": "71", "hidden": true}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "text", "content": "74"}, {"type": "theorem", "text": "75", "lean": "theorem succ_add (a b: N) : succ(a) + b = succ(a + b) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 26, "textBefore": "-- Level name : Addition mit dem Nachfolger - von links\n\nimport natnum.add -- hide\nimport game.Addition.level_4 --hide\nnamespace N -- hide\n\n/-\nGenauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n-/\n\n/- Theorem\n`succ`$(a)+b = $`succ`$(a+b)$\n-/\ntheorem succ_add (a b: N) : succ(a) + b = succ(a + b) :=\nbegin\n", "proof": "  induction b with d hd,\n  {rw add_zero,\n  rw add_zero,},\n  {rw add_succ,\n  rw hd,\n  rw add_succ,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 9, "editorText": "sorry", "lineOffset": 17, "name": "succ_add", "statement": "(a b: N) : succ(a) + b = succ(a + b)"}, {"type": "lean", "content": "76", "hidden": true}]}, {"name": "77", "problemIndex": 4, "objects": [{"type": "lean", "content": "78", "hidden": true}, {"type": "lean", "content": "79", "hidden": true}, {"type": "lean", "content": "80", "hidden": true}, {"type": "text", "content": "81"}, {"type": "theorem", "text": "82", "lean": "theorem add_komm (a b: N) : a + b = b + a :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 28, "textBefore": "-- Level name : Kommutativit\u00e4t der Addition\n\nimport natnum.add -- hide\nimport game.Addition.level_5 --hide\nnamespace N -- hide\n\n/-\nEndlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_6\" target=\"blank\">hier</a> ein Aufgabenblatt.\n-/\n\n/- Theorem\na+b=b+a\n-/\ntheorem add_komm (a b: N) : a + b = b + a :=\nbegin\n", "proof": "  induction b with d hd,\n  {/- Induktionsanfang -/\n  rw add_zero,\n  rw zero_add,},\n  {/- Induktionsschritt -/\n  rw add_succ,\n  rw hd,\n  rw succ_add,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 11, "editorText": "sorry", "lineOffset": 17, "name": "add_komm", "statement": "(a b: N) : a + b = b + a"}, {"type": "lean", "content": "83", "hidden": true}]}, {"name": "84", "problemIndex": 4, "objects": [{"type": "lean", "content": "85", "hidden": true}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "text", "content": "88"}, {"type": "theorem", "text": "89", "lean": "theorem add_right_komm (a b c: N) : a + b + c = a + c + b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 33, "textBefore": "-- Level name : Kommutativit\u00e4t der rechten Summanden\n\nimport natnum.add -- hide\nimport game.Addition.level_6 --hide\nnamespace N -- hide\n\n/-\nDas Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_komm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assoziativit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts Weiteres spezifizierst, wird LEAN die erste dieser\nStellen heraussuchen. Wenn du zum Beispiel in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoz,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assoziativit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoz a c b,`.\n-/\n\n/- Theorem\n$a+b+c=a+c+b$\n-/\ntheorem add_right_komm (a b c: N) : a + b + c = a + c + b :=\nbegin\n", "proof": "rw add_assoz a b c,\nrw add_komm b c,\nrw \u2190 add_assoz a c b,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 27, "name": "add_right_komm", "statement": "(a b c: N) : a + b + c = a + c + b"}, {"type": "lean", "content": "90", "hidden": true}]}], "parents": [0]}, {"name": "91", "levels": [{"name": "92", "problemIndex": 4, "objects": [{"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "theorem", "text": "97", "lean": "theorem succ_non_hom (a b: N) : succ(a) + succ(b) = succ(a + b) + one :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 26, "textBefore": "-- Level name : Die succ Abbildung ist kein Homomorphismus\n\nimport natnum.add -- hide\nimport game.Addition.level_7 --hide\nnamespace N -- hide\n\n/-\nF\u00fcr zwei Mengen mit Verkn\u00fcpfung $(M, $\u2217$), (N, $\u22c6$)$ ist eine Abbildung $f: M $\u2192$ N$\nein Homomorphismus, falls $f(m_1)$ \u22c6 $f(m_2) = f(m_1$ \u2217 $m_2)$ f\u00fcr alle $m_1, m_2$ in M.\n\nDie Abbildung `succ` ist eine Abbildung `succ`$: \\mathbb{N}$ \u2192 $\\mathbb{N}$. Wir haben\nauf der Menge der nat\u00fcrlichen Zahlen die Addition als Verkn\u00fcpfung definiert. Wir werden\nnun sehen, dass diese Abbildung kein Homomorphismus bez\u00fcglich der Addition ist.\n-/\n\n/- Theorem\n`succ`$(a) +$ `succ`$(b) =$ `succ`$(a + b) + 1$\n-/\ntheorem succ_non_hom (a b: N) : succ(a) + succ(b) = succ(a + b) + one :=\nbegin\n", "proof": "rw add_succ,\nrw succ_eq_add_one (a.succ+b),\nrw succ_add,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 20, "name": "succ_non_hom", "statement": "(a b: N) : succ(a) + succ(b) = succ(a + b) + one"}, {"type": "lean", "content": "98", "hidden": true}]}], "parents": [1]}, {"name": "99", "levels": [{"name": "100", "problemIndex": 8, "objects": [{"type": "lean", "content": "101", "hidden": true}, {"type": "lean", "content": "102", "hidden": true}, {"type": "lean", "content": "103", "hidden": true}, {"type": "axiom", "content": "104", "name": "mul_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "105", "name": "mul_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "106"}, {"type": "hint", "content": "107", "title": "108"}, {"type": "text", "content": "109"}, {"type": "theorem", "text": "110", "lean": "theorem zero_mul (a: N) : zero*a = zero :=\n", "sideBar": true, "firstProofLineNumber": 49, "lastProofLineNumber": 56, "textBefore": "-- Level name : Die Multiplikation\n\nimport natnum.mul -- hide\nimport game.Addition_Extra.level_1 --hide\nnamespace N -- hide\n\n/- Axiom : mul_zero (a : N) :\na * 0 = 0\n-/\n\n/- Axiom : mul_succ (a b : N) :\na * succ(b) = a*d+a\n-/\n\n/-\nMan kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def mul : N \u2192 N \u2192 N` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : N) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : N) : a * (succ d) = a * d + a := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt.\n-/\n\n/- Theorem\n$0*a=0$\n-/\ntheorem zero_mul (a: N) : zero*a = zero :=\nbegin\n", "proof": "induction a with d hd,\n{rw mul_zero,},\n{rw mul_succ,\nrw hd,\nrw add_zero,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 8, "editorText": "sorry", "lineOffset": 48, "name": "zero_mul", "statement": "(a: N) : zero*a = zero"}, {"type": "lean", "content": "111", "hidden": true}]}, {"name": "112", "problemIndex": 5, "objects": [{"type": "lean", "content": "113", "hidden": true}, {"type": "lean", "content": "114", "hidden": true}, {"type": "lean", "content": "115", "hidden": true}, {"type": "tactic", "content": "116", "name": "repeat", "sideBar": true}, {"type": "text", "content": "117"}, {"type": "theorem", "text": "118", "lean": "theorem succ_mul (a b : N) : succ(a) * b = a * b + b :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 49, "textBefore": "-- Level name : Multiplikation mit dem Nachfolger - von links\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_1 --hide\nnamespace N -- hide\n\n/- Tactic : repeat\n## Anleitung\nfalls du in der zu beweisenden Aussage einen Befehl (z.B. `rw add_zero,`) mehrmals\nanwenden kannst, dann wird `{repeat {\u2b1d,},` den Befehl so oft ausf\u00fchren, bis es\nkeine Instanz mehr gibt, an der der Befehl ausgef\u00fchrt werden kann.\n## Beispiel\nBei folgendem Zustand:\n```\na b : N\n\u22a2 a + zero + b = a + (b + zero)\n```\nwird `{repeat {rw add_zero,},` zweimal `add_zero` anwenden und\nsomit das Ziel zu `\u22a2 a + b = a + b ` umformen und damit\nl\u00f6sen.\n-/\n\n/-\nManchmal m\u00f6chtest du einen Befehl mehrmals hintereinander ausf\u00fchren. Wenn du dir\nzum Beispiel den Induktionsanfang dieses Levels anschaust, musst du zeigen, dass\n`a.succ * zero = a * zero + zero`, du k\u00f6nntest damit anfangen, \u00fcberall wo mit\n$0$ multipliziert wird `rw mul_zero,` anzuwenden. Anstatt den Befehl zweimal\nauszuschreiben, kannst du `{repeat {rw mul_zero,},` anwenden. Dann wird LEAN den\nBefehl `rw mul_zero,` so oft ausf\u00fchren, bis es keine Instanz der Form `a+zero` gibt.\n-/\n\n/- Theorem\n`succ`$(a) * b = a * b + b$\n-/\ntheorem succ_mul (a b : N) : succ(a) * b = a * b + b :=\nbegin\n", "proof": "induction b with d hd,\n{repeat {rw mul_zero,},\nrw add_zero,},\n{rw mul_succ,\nrw mul_succ,\nrw hd,\nrw add_succ,\nrw add_succ,\nrw add_right_komm,\n},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 13, "editorText": "sorry", "lineOffset": 36, "name": "succ_mul", "statement": "(a b : N) : succ(a) * b = a * b + b"}, {"type": "lean", "content": "119", "hidden": true}]}, {"name": "120", "problemIndex": 4, "objects": [{"type": "lean", "content": "121", "hidden": true}, {"type": "lean", "content": "122", "hidden": true}, {"type": "lean", "content": "123", "hidden": true}, {"type": "text", "content": "124"}, {"type": "theorem", "text": "125", "lean": "theorem mul_komm (a b : N) : a * b = b * a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 24, "textBefore": "-- Level name : Kommutativit\u00e4t der Multiplikation\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_2 -- hide\nnamespace N -- hide\n\n/- \nDie Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t zu zeigen!\n-/\n\n/- Theorem\na * b = b * a\n-/\ntheorem mul_komm (a b : N) : a * b = b * a :=\nbegin\n", "proof": "induction b with d hd,\n{rw mul_zero,\nrw zero_mul,},\n{rw mul_succ,\nrw hd,\nrw succ_mul,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint :  Kommen dir die Schritte in diesem Beweis bekannt vor?\nWenn du dir den Beweis der Kommutativit\u00e4t der Addition anschaust und dort\ndas \u00fcberall \"add\" mit \"mul\" ersetzt, hast du einen g\u00fcltigen Beweis f\u00fcr\ndie Kommutativit\u00e4t der Multiplikation!\n-/", "height": 9, "editorText": "sorry", "lineOffset": 15, "name": "mul_komm", "statement": "(a b : N) : a * b = b * a"}, {"type": "lean", "content": "126", "hidden": true}, {"type": "hint", "content": "127", "title": "128"}]}, {"name": "129", "problemIndex": 4, "objects": [{"type": "lean", "content": "130", "hidden": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "lean", "content": "132", "hidden": true}, {"type": "text", "content": "133"}, {"type": "theorem", "text": "134", "lean": "theorem distr (a b c : N) : c * (a + b) = c * a + c * b :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 28, "textBefore": "-- Level name : Das Distributivgesetz\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_3 -- hide\nnamespace N -- hide\n\n/-\nDas Distributivgesetz gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen, in denen\nAddition und Multiplikation vorkommen.\n-/\n\n/- Theorem\n$c * (a + b) = c * a + c * b$\n-/\ntheorem distr (a b c : N) : c * (a + b) = c * a + c * b :=\nbegin\n", "proof": "induction b with d hd,\n{rw add_zero,\nrw mul_zero,\nrw add_zero,},\n{rw add_succ,\nrw mul_succ,\nrw hd,\nrw mul_succ,\nrw add_assoz,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 12, "editorText": "sorry", "lineOffset": 16, "name": "distr", "statement": "(a b c : N) : c * (a + b) = c * a + c * b"}, {"type": "lean", "content": "135", "hidden": true}]}, {"name": "136", "problemIndex": 4, "objects": [{"type": "lean", "content": "137", "hidden": true}, {"type": "lean", "content": "138", "hidden": true}, {"type": "lean", "content": "139", "hidden": true}, {"type": "text", "content": "140"}, {"type": "theorem", "text": "141", "lean": "theorem mul_assoz (a b c : N) : (a * b) * c = a * (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 25, "textBefore": "-- Level name : Assoziativit\u00e4t der Multiplikation\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_4 -- hide\nnamespace N -- hide\n\n/-\n\n\n\n-/\n\n/- Theorem\n$(a * b) * c = a * (b * c)$\n-/\ntheorem mul_assoz (a b c : N) : (a * b) * c = a * (b * c) :=\nbegin\n", "proof": "induction c with d hd,\n{repeat {rw mul_zero,},},\n{repeat{rw mul_succ},\nrw distr,\nrw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint :  Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?\nNein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetz. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n-/", "height": 8, "editorText": "sorry", "lineOffset": 17, "name": "mul_assoz", "statement": "(a b c : N) : (a * b) * c = a * (b * c)"}, {"type": "lean", "content": "142", "hidden": true}, {"type": "hint", "content": "143", "title": "144"}]}], "parents": [1]}, {"name": "145", "levels": [{"name": "146", "problemIndex": 4, "objects": [{"type": "lean", "content": "147", "hidden": true}, {"type": "lean", "content": "148", "hidden": true}, {"type": "lean", "content": "149", "hidden": true}, {"type": "text", "content": "150"}, {"type": "theorem", "text": "151", "lean": "theorem mul_one (a: N) : a*one = a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 22, "textBefore": "-- Level name : Multiplikation mit 1\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_5 -- hide\nnamespace N -- hide\n\n/-\n\n-/\n\n/- Theorem\n$a * 1 = a$\n-/\ntheorem mul_one (a: N) : a*one = a :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw mul_succ,\nrw mul_zero,\nrw zero_add,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 7, "editorText": "sorry", "lineOffset": 15, "name": "mul_one", "statement": "(a: N) : a*one = a"}, {"type": "lean", "content": "152", "hidden": true}]}, {"name": "153", "problemIndex": 4, "objects": [{"type": "lean", "content": "154", "hidden": true}, {"type": "lean", "content": "155", "hidden": true}, {"type": "lean", "content": "156", "hidden": true}, {"type": "text", "content": "157"}, {"type": "theorem", "text": "158", "lean": "theorem one_mul (a: N) : one*a = a :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 25, "textBefore": "-- Level name : Multiplikation mit 1 - von links\n\nimport natnum.mul -- hide\nimport game.Multiplikation_Extra.level_1 -- hide\nnamespace N -- hide\n\n/-\nDu hast zwei Optionen f\u00fcr dieses Level. Du kannst mit Induktion starten,\noder du k\u00f6nntest ausnutzen, dass wir gezeigt haben, dass die Multiplikation\nkommutativ ist! \n-/\n\n/- Theorem\n1 * a = a\n-/\ntheorem one_mul (a: N) : one*a = a :=\nbegin\n", "proof": "induction a with d hd,\n{rw mul_zero,},\n{rw mul_succ,\nrw hd,\nrw succ_eq_add_one,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 8, "editorText": "sorry", "lineOffset": 17, "name": "one_mul", "statement": "(a: N) : one*a = a"}, {"type": "lean", "content": "159", "hidden": true}]}, {"name": "160", "problemIndex": 4, "objects": [{"type": "lean", "content": "161", "hidden": true}, {"type": "lean", "content": "162", "hidden": true}, {"type": "lean", "content": "163", "hidden": true}, {"type": "text", "content": "164"}, {"type": "theorem", "text": "165", "lean": "theorem add_mul (a b c: N) : (a + b) * c = a * c + b * c :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 33, "textBefore": "-- Level name : Distributivgesetz - von links\n\nimport natnum.mul -- hide\nimport game.Multiplikation_Extra.level_2 -- hide\nnamespace N -- hide\n\n/-\nWir haben das Distributivgesetz gezeigt, wir k\u00f6nnten es aber manchmal auch von\nlinks gebrauchen. Um uns in diesen F\u00e4llen Schreibarbeit zu sparen, zeigen wir hier,\ndass es auch von links gilt. Auch hier kannst du deinen Beweis \u00fcber Induktion f\u00fchren\noder Kommutativit\u00e4t nutzen. Kannst du beide Wege coden?\n-/\n\n/- Theorem\n$(a + b) * c = a * c + b * c$\n-/\ntheorem add_mul (a b c: N) : (a + b) * c = a * c + b * c :=\nbegin\n", "proof": "induction c with d hd,\n{repeat {rw mul_zero},\nrw add_zero,},\n\n{rw mul_succ,\nrw hd,\nrepeat {rw mul_succ},\nrw add_assoz (a*d) (b*d) (a + b),\nrw \u2190 add_assoz (b*d) a b,\nrw add_komm (b*d) a,\nrw add_assoz a (b*d) b,\nrw \u2190 add_assoz (a*d) a (b * d + b),},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 15, "editorText": "sorry", "lineOffset": 18, "name": "add_mul", "statement": "(a b c: N) : (a + b) * c = a * c + b * c"}, {"type": "lean", "content": "166", "hidden": true}]}, {"name": "167", "problemIndex": 4, "objects": [{"type": "lean", "content": "168", "hidden": true}, {"type": "lean", "content": "169", "hidden": true}, {"type": "lean", "content": "170", "hidden": true}, {"type": "text", "content": "171"}, {"type": "theorem", "text": "172", "lean": "theorem mul_left_comm (a b c : N) : a * (b * c) = b * (a * c) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 23, "textBefore": "-- Level name : Kommutativit\u00e4t der linken Faktoren\n\nimport natnum.mul -- hide\nimport game.Multiplikation_Extra.level_3 -- hide\nnamespace N -- hide\n\n/-\nDieses Level erinnert dich vielleicht an den Beweis von `add_right_komm`. Es geht wieder darum, die\nKommutativit\u00e4t von zwei Faktoren zu zeigen, die in der Operatorrangfolge nicht als Erstes miteinander\nverkn\u00fcpft werden.\n-/\n\n/- Theorem\na * (b * c) = b * (a * c)\n-/\ntheorem mul_left_comm (a b c : N) : a * (b * c) = b * (a * c) :=\nbegin\n", "proof": "rw \u2190 mul_assoz b a c,\nrw mul_komm b a,\nrw mul_assoz a b c,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 17, "name": "mul_left_comm", "statement": "(a b c : N) : a * (b * c) = b * (a * c)"}, {"type": "lean", "content": "173", "hidden": true}]}], "parents": [3]}, {"name": "174", "levels": [{"name": "175", "problemIndex": 8, "objects": [{"type": "lean", "content": "176", "hidden": true}, {"type": "lean", "content": "177", "hidden": true}, {"type": "lean", "content": "178", "hidden": true}, {"type": "axiom", "content": "179", "name": "pow_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "180", "name": "pow_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "181"}, {"type": "hint", "content": "182", "title": "183"}, {"type": "text", "content": "184"}, {"type": "theorem", "text": "185", "lean": "theorem zero_pow_zero : (zero) ^ (zero) = one :=\n", "sideBar": true, "firstProofLineNumber": 48, "lastProofLineNumber": 51, "textBefore": "-- Level name : Die Potenzierung\n\nimport natnum.pow -- hide\nimport game.Multiplikation_Extra.level_4 -- hide\nnamespace N -- hide\n\n/- Axiom : pow_zero (a : N) :\na ^ 0 = 1\n-/\n\n/- Axiom : pow_succ (a b : N) :\na ^ succ(b) = a^b*a\n-/\n\n/-\nMan kann auch die Potenzierung einer nat\u00fcrlichen Zahl mit einer anderen \nrekursiv anhand der Peano-Axiome definieren.\n- F\u00fcr $m \\in \\mathbb{N}$ sei $m^0=1$\n- F\u00fcr $m,n \\in \\mathbb{N}$ sei $m^{(succ(n))} = m^n*m$\n\nNach dem Prinzip der Induktion ist dann die Potenzierung f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Potenzierung definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `pow_zero` und `pow_succ`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Potenzierung der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def pow : N \u2192 N \u2192 N` <br>\n`| m zero := one` <br>\n`| m (succ n) := pow m n * m` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma pow_zero (m : N) : m ^ (zero : N) = one := rfl` <br>\n`lemma pow_succ (m n : N) : m ^ (succ n) = m ^ n * m := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass nach Definition gilt, dass $0^0=1$.\n-/\n\n/- Theorem\n$0^0=1$\n-/\ntheorem zero_pow_zero : (zero) ^ (zero) = one :=\nbegin\n", "proof": "rw pow_zero,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 4, "editorText": "sorry", "lineOffset": 47, "name": "zero_pow_zero", "statement": "(zero) ^ (zero) = one"}, {"type": "lean", "content": "186", "hidden": true}]}, {"name": "187", "problemIndex": 5, "objects": [{"type": "lean", "content": "188", "hidden": true}, {"type": "lean", "content": "189", "hidden": true}, {"type": "lean", "content": "190", "hidden": true}, {"type": "text", "content": "191"}, {"type": "hint", "content": "192", "title": "193"}, {"type": "theorem", "text": "194", "lean": "theorem zero_pow_succ (a : N) : (zero) ^ (succ(a)) = zero :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 28, "textBefore": "-- Level name : 0 hoch etwas ergibt 0\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_1 -- hide\nnamespace N -- hide\n\n/-\n\nIn diesem Level zeigen wir, dass $0$ hoch jedem Nachfolger einer nat\u00fcrlichen Zahl\n$0$ ergibt.\n\n-/\n\n/- Hint :  Wieso folgt daraus nicht $0^0=0$, was ein Widerspruch zu Level 1 ist?\nIn den Peano-Axiomen steht, dass $0$ nicht der Nachfolger einer Zahl ist. Deswegen\nzeigen wir hier $0^{(succ(a))}=0$ und nicht $0^a=0$. Wir schlie\u00dfen so die $0$ aus.\n-/\n\n/- Theorem\n$0^{(succ(a))}=0$\n-/\ntheorem zero_pow_succ (a : N) : (zero) ^ (succ(a)) = zero :=\nbegin\n", "proof": "rw pow_succ,\nrw mul_zero,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 5, "editorText": "sorry", "lineOffset": 23, "name": "zero_pow_succ", "statement": "(a : N) : (zero) ^ (succ(a)) = zero"}, {"type": "lean", "content": "195", "hidden": true}]}, {"name": "196", "problemIndex": 4, "objects": [{"type": "lean", "content": "197", "hidden": true}, {"type": "lean", "content": "198", "hidden": true}, {"type": "lean", "content": "199", "hidden": true}, {"type": "text", "content": "200"}, {"type": "theorem", "text": "201", "lean": "theorem pow_one (a : N) : (a) ^ (one) = a :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "-- Level name : Hoch $1$ nehmen\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_2 -- hide\nnamespace N -- hide\n\n/-\n\n\n\n-/\n\n/- Theorem\n$a^1 = a$\n-/\ntheorem pow_one (a : N) : (a) ^ (one) = a :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw pow_succ,\nrw pow_zero,\nrw one_mul,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "pow_one", "statement": "(a : N) : (a) ^ (one) = a"}, {"type": "lean", "content": "202", "hidden": true}]}, {"name": "203", "problemIndex": 4, "objects": [{"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "text", "content": "207"}, {"type": "theorem", "text": "208", "lean": "theorem one_pow (a : N) : (one) ^ (a) = one :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 25, "textBefore": "-- Level name : $1$ hoch etwas\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_3 -- hide\nnamespace N -- hide\n\n/-\n\n\n\n-/\n\n/- Theorem\n$1^a=1$\n-/\ntheorem one_pow (a : N) : (one) ^ (a) = one :=\nbegin\n", "proof": "induction a with d hd,\n{rw pow_zero,},\n{rw pow_succ,\nrw mul_one,\nrw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 8, "editorText": "sorry", "lineOffset": 17, "name": "one_pow", "statement": "(a : N) : (one) ^ (a) = one"}, {"type": "lean", "content": "209", "hidden": true}]}, {"name": "210", "problemIndex": 4, "objects": [{"type": "lean", "content": "211", "hidden": true}, {"type": "lean", "content": "212", "hidden": true}, {"type": "lean", "content": "213", "hidden": true}, {"type": "text", "content": "214"}, {"type": "theorem", "text": "215", "lean": "theorem pow_add (a b c : N) : a ^ (b + c) = a ^ b * a ^ c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 29, "textBefore": "-- Level name : Potenzieren als Homomorphismus $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_4 -- hide\nnamespace N -- hide\n\n/-\nWenn wir das Potenzieren als Abbildung $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ein Homomorphismus, da $a^{b + c} = a^b * a^c$. Dies \nist eines der Potenzgesetze.\n-/\n\n/- Theorem\n$a^{b + c} = a^b * a^c$\n-/\ntheorem pow_add (a b c : N) : a ^ (b + c) = a ^ b * a ^ c :=\nbegin\n", "proof": "induction c with d hd,\n{rw add_zero,\nrw pow_zero,\nrw mul_one,},\n{rw add_succ,\nrepeat{rw pow_succ},\nrw hd,\nrw \u2190 mul_assoz (a^b) (a^d) a,\n},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 12, "editorText": "sorry", "lineOffset": 17, "name": "pow_add", "statement": "(a b c : N) : a ^ (b + c) = a ^ b * a ^ c"}, {"type": "lean", "content": "216", "hidden": true}]}, {"name": "217", "problemIndex": 4, "objects": [{"type": "lean", "content": "218", "hidden": true}, {"type": "lean", "content": "219", "hidden": true}, {"type": "lean", "content": "220", "hidden": true}, {"type": "text", "content": "221"}, {"type": "theorem", "text": "222", "lean": "theorem mul_pow (a b c : N) : (a * b) ^ c = a ^ c * b ^ c :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 34, "textBefore": "-- Level name : Potenzieren als Homomorphismus $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_5 -- hide\nnamespace N -- hide\n\n/-\nWenn wir das Potenzieren als Abbildung $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ebenfalls ein Homomorphismus, da $(a * b)^c = a^c * b^c$. \nDies ist ein weiteres der Potenzgesetze.\n\nDas Potenzieren ist also sowohl im ersten als auch im zweiten Argument ein\nHomomorphismus, aber jeweils bez\u00fcglich einer anderen Verkn\u00fcpfung in der Urbildmenge.\n-/\n\n/- Theorem\n$(a * b)^c = a^c * b^c$\n-/\ntheorem mul_pow (a b c : N) : (a * b) ^ c = a ^ c * b ^ c :=\nbegin\n", "proof": "induction c with d hd,\n{repeat {rw pow_zero},\nrw mul_one,},\n{repeat {rw pow_succ},\nrw hd,\nrw mul_assoz (a ^ d) (b ^ d) (a * b),\nrw \u2190 mul_assoz (b^d) a b,\nrw mul_komm (b^d) a,\nrw mul_assoz a (b^d) b,\nrw \u2190 mul_assoz (a^d) a (b^d*b),\n},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 14, "editorText": "sorry", "lineOffset": 20, "name": "mul_pow", "statement": "(a b c : N) : (a * b) ^ c = a ^ c * b ^ c"}, {"type": "lean", "content": "223", "hidden": true}]}, {"name": "224", "problemIndex": 4, "objects": [{"type": "lean", "content": "225", "hidden": true}, {"type": "lean", "content": "226", "hidden": true}, {"type": "lean", "content": "227", "hidden": true}, {"type": "text", "content": "228"}, {"type": "theorem", "text": "229", "lean": "theorem pow_pow (a b c : N) : (a ^ b) ^ c = a ^ (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 25, "textBefore": "-- Level name : Potenz einer Potenz\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_6 -- hide\nnamespace N -- hide\n\n/-\nEs geht weiter mit noch einem Potenzgesetz.\n-/\n\n/- Theorem\n$(a^b)^c = a^{b * c}$\n-/\ntheorem pow_pow (a b c : N) : (a ^ b) ^ c = a ^ (b * c) :=\nbegin\n", "proof": "induction c with d hd,\n{rw mul_zero,\nrepeat {rw pow_zero},},\n{rw mul_succ,\nrw pow_add,\nrw pow_succ,\nrw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 10, "editorText": "sorry", "lineOffset": 15, "name": "pow_pow", "statement": "(a b c : N) : (a ^ b) ^ c = a ^ (b * c)"}, {"type": "lean", "content": "230", "hidden": true}]}, {"name": "231", "problemIndex": 6, "objects": [{"type": "lean", "content": "232", "hidden": true}, {"type": "lean", "content": "233", "hidden": true}, {"type": "lean", "content": "234", "hidden": true}, {"type": "axiom", "content": "235", "name": "two_eq_succ_one (a : N) :", "sideBar": true}, {"type": "text", "content": "236"}, {"type": "hint", "content": "237", "title": "238"}, {"type": "theorem", "text": "239", "lean": "theorem add_squared (a b : N) : (a + b) ^ two = a ^ two + two * a * b + b ^ two:=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 51, "textBefore": "-- Level name : Erste Binomische Formel\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_7 -- hide\nnamespace N -- hide\n\n/- Axiom : two_eq_succ_one (a : N) :\ntwo = succ(one)\n-/\n\n/-\nDu bist auf dem letzten Level angekommen! Mit allem, was wir\nbisher bewiesen haben, k\u00f6nnen wir die erste binomische Formel\nbeweisen. Das wird aber einige Beweisschritte erfordern.\n\nIn diesem Level kommt die zwei zum ersten Mal explizit vor. Anstatt\n`succ(one)` wollen wir einen Namen einf\u00fchren: `two`. Zus\u00e4tzlich m\u00f6chten wir\nbenutzen k\u00f6nnen, dass `two=succ(one)` ist, diese Aussage nennen wir \n`two_eq_succ_one`.\n-/\n\n/- Hint : Klicke hier, um die Definition von `two` in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def two : N := succ(succ(0))` <br>\n\nDieser Eigenschaften wird ein Namen gegeben: <br>\n`theorem two_eq_succ_one : two = succ(succ(zero)) := rfl`\n-/\n\n/- Theorem\n$(a+b)^2 = a^2+2*a*b+b^2$\n-/\ntheorem add_squared (a b : N) : (a + b) ^ two = a ^ two + two * a * b + b ^ two:=\nbegin\n", "proof": "rw two_eq_succ_one,\nrepeat{rw pow_succ},\nrepeat{rw pow_one},\nrw distr,\nrepeat{rw add_mul},\nrw succ_mul,\nrw \u2190 one_eq_succ_zero,\nrepeat {rw pow_zero,},\nrepeat{rw one_mul,},\nrepeat{rw add_mul,},\nrw mul_komm b a,\nrw add_assoz (a*a) (a*b) (a*b + b*b),\nrw add_assoz (a*a) (a*b+a*b) (b*b),\nrw add_assoz (a*b) (a*b) (b*b),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 17, "editorText": "sorry", "lineOffset": 34, "name": "add_squared", "statement": "(a b : N) : (a + b) ^ two = a ^ two + two * a * b + b ^ two"}, {"type": "lean", "content": "240", "hidden": true}]}], "parents": [3]}], "texts": [["Die nat\u00fcrlichen Zahlen", "intro", "# Die nat\u00fcrlichen Zahlen\n## Worum geht es in diesem Spiel?\n### Mathematisch \nIn der Schule lernen wir die nat\u00fcrlichen Zahlen kennen und wir lernen, wie \nwir mit ihnen elementare Rechenoperationen durchf\u00fchren. Dabei wird aber nicht \nauf die formale Definition eingegangen.\n\nIn dieser Einheit m\u00f6chten wir die Definition der nat\u00fcrlichen Zahlen nach Peano\nbetrachten. Grob gesagt entstehen damit die nat\u00fcrlichen Zahlen aus der 0 zusammen \nmit Rekursion. \u00dcber die Rekursion kann dann die Addition, Multiplikation und \nPotenzierung definiert werden. F\u00fcr diese Rechenoperationen werden wir dann die \ngrundlegenden Eigenschaften wie Kommutativit\u00e4t und Assoziativit\u00e4t zeigen.\n\n### Technologisch\nWir werden die Programmiersprache \n<a href=\"https://leanprover-community.github.io/\" target=\"blank\">LEAN</a> kennenlernen.\nLEAN ist ein interaktiver Theorembeweiser. In einem Theorembeweiser kann man\neinen Beweis Schritt f\u00fcr Schritt (in Computersprache) eingeben. Dieser \u00fcberpr\u00fcft\ndann, ob der Beweis korrekt ist und kann an jeder Stelle des Beweises Feedback zum\naktuellen Stand des Beweises geben.\n\n\n## Eine kurze Anleitung.\nMit diesem Tool kannst du an dieser Einheit arbeiten. Die Einheit ist in die Kapitel\nPeano, Addition, Multiplikation und Potenzen eingeteilt. Bei der Addition und der \nMultiplikation gibt es zus\u00e4tzliche Kapitel mit Extra-Aufgaben. Jedes Kapitel hat \nmehrere Level. Am besten ist es, wenn du die Kapitel und Level der Reihe nach \nbearbeitest. Eine Ausnahme sind die Extra-Kapitel, die nicht erforderlich sind,\num mit dem n\u00e4chsten Kapitel weiterzumachen.\n\nIn jedem Level gibt es als Erstes einen Text, der den mathematischen Inhalt und die \nn\u00f6tigen LEAN-Anleitungen des Levels einf\u00fchrt. Darunter ist die zu l\u00f6sende Aufgabe:\nder Beweis eines Satzes, der in LEAN ausgef\u00fchrt werden soll.\n\nDein Fortschritt wird nicht automatisch gespeichert. Um beim n\u00e4chsten Mal dort\nweiterzumachen, wo du aufgeh\u00f6rt hast, solltest du vor dem Schlie\u00dfen dieses Fensters\nden \ud83d\udcbe Button \u00fcber dem Spielbaum klicken. Damit wird dein Spielstand in einer json-Datei gespeichert.\nDiese kannst du beim n\u00e4chsten Mal hochladen, indem du den \ud83d\udcdd Button klickst. \n\nViel Spa\u00df beim Coden!\n\n## Du bist mit dem Tool fertig - was nun?\n\nDieses Tool ist eine Anpassung der ersten Levels in dem \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Number Game</a>\nvon Kevin Buzzard. Du kannst dort noch mehr Levels l\u00f6sen und viele andere Befehle\nkennenlernen (In unserem Modul haben wir nur `rw` und `induction` verwendet). Die LEAN Version dort\nist etwas \u00e4lter und einige Dinge funktionieren leicht anders, am besten solltest\ndu also die ersten paar Levels wieder l\u00f6sen.\n", "Peano", "Die Peano Axiome", "-- namespace nat -- hide \n", "import natnum.definition -- hide\n", "namespace N -- hide\n", "Die nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN: `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N}$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\nIn LEAN kann man die Anwendung der Abbildung `succ` auf `a` sowohl als `succ(a)` als auch \nals `a.succ` schreiben.\n", "Wir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n", "Wieso brauchen wir hier die Abbildung `succ`, um den Nachfolger einer Zahl $n$ zu beschreiben, anstatt den Ausdruck n+1 zu verwenden?", "Aus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen uns nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nN arbeiten, die genau nach den Axiomen von Peano definiert ist.\n", "`inductive N` \u2192 $A_4$ <br>\n`| zero : N` \u2192 $A_1$ <br>\n`| succ (n : N) : N` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : N} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : N) : (zero : N) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n", "Klicke hier, um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Als Erstes muss man das Lemma definieren, das man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`.\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein Keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses Keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinweisen, dass noch etwas zu tun ist. L\u00f6sche als\nErstes das `sorry`, um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehl. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehst, \u00fcberpr\u00fcfe deinen Code auf fehlende Kommata.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisches Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das, was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen.\n", "Falls `succ`$(a) = b$, dann `succ`$($`succ`$(a)) = $`succ`$(b)$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end N -- hide", "Die Peano Axiome - Teil 2", "-- namespace nat -- hide \n", "import natnum.definition -- hide\n", "import game.Peano.level_1 --hide\n", "namespace N -- hide\n", "In diesem Level passiert nicht viel. Es dient eher zur \u00dcbung von dem Gelernten in\nLevel 1.\n\nVielleicht hast du gemerkt, dass es eine linke Spalte gibt. Hier kannst du alle\nTools finden, die du zum Beweisen brauchst. Das sind einerseits die Befehle (wie\nz.B. `rw`), die in LEAN Tactics hei\u00dfen. Andererseits sind das die Axiome und Aussagen,\ndie wir bereits eingef\u00fchrt/bewiesen haben. Diese sind in der Kategorie Theorem\nstatements. Umso weiter du bist, umso mehr Inhalt wirst du hier finden.\n\nWir werden aber auch die Gelegenheit nutzen, um uns den `rw` Befehl nochmal\nanzuschauen. Wir haben gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetzt. Aber wie\nkann man jedes `b` durch ein `a` ersetzen? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg?\n", "Falls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$\n", "end N -- hide\n", "In der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n", "Brauchst du Hilfe, um einen zweiten Weg zu finden?", "Addition", "Die Addition", "import natnum.add -- hide\n", "import game.Peano.level_2 --hide\n", "namespace N -- hide\n", "a + 0 = a\n", "a + succ(b) = succ(a + b)\n", "Man kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n", "Definition: <br>\n`def add : N \u2192 N \u2192 N` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : N) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : N) : m + succ n = succ (m + n) := rfl`\n", "Klicke hier, um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\n", "$a+$`succ`$(0)=$`succ`$(a)$\n", "end N -- hide", "Die nat\u00fcrliche Zahl 1", "import natnum.add -- hide\n", "import game.Addition.level_1 --hide\n", "namespace N -- hide\n", "one = succ(zero)\n", "Aus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n", "`def one : N := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n", "Klicke hier, um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Nun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. \n", "`succ`$(a) = a + 1$\n", "end N -- hide", "Addition mit 0 - von links", "import natnum.add -- hide\n", "import game.Addition.level_2 --hide\n", "namespace N -- hide\n", "## Anleitung\nfalls `n : N` gegeben ist, dann startet `induction n with d hd`\neinen Induktionsbeweis \u00fcber `n` der zu beweisenden Aussage. `d` wird \nder Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n## Beispiel\nBei folgendem Zustand:\n```\nn : N\n\u22a2 2 * n = n + n\n```\ndann wird `induction n with d hd` zwei neue Ziele \u00f6ffnen:\n```\n\u22a2 2 * 0 = 0 + 0\n```\nund\n```\nd : mynat,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n", "Nach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir den `induction` Befehl in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\naufrufen. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_3\" target=\"blank\">hier</a> ein Aufgabenblatt.\n", "$0+a=a$\n", "end N -- hide", "Assoziativit\u00e4t der Addition", "import natnum.add -- hide\n", "import game.Addition.level_3 --hide\n", "namespace N -- hide\n", "Nun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. \n", "Wir haben die Addition mit Rekursion auf die rechte Variable definiert,\nes ist also sinnvoll bei dem Induktionsbeweis \u00fcber die Variable\n$c$ zu induzieren.\n", "\u00dcber welcher der drei Variablen ist ein Induktionsbeweis am sinnvollsten?", "Noch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_4\" target=\"blank\">hier</a> ein Aufgabenblatt.\n", "$(a + b) + c = a + (b + c)$\n", "end N -- hide", "Addition mit dem Nachfolger - von links", "import natnum.add -- hide\n", "import game.Addition.level_4 --hide\n", "namespace N -- hide\n", "Genauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n", "`succ`$(a)+b = $`succ`$(a+b)$\n", "end N -- hide", "Kommutativit\u00e4t der Addition", "import natnum.add -- hide\n", "import game.Addition.level_5 --hide\n", "namespace N -- hide\n", "Endlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_6\" target=\"blank\">hier</a> ein Aufgabenblatt.\n", "a+b=b+a\n", "end N -- hide", "Kommutativit\u00e4t der rechten Summanden", "import natnum.add -- hide\n", "import game.Addition.level_6 --hide\n", "namespace N -- hide\n", "Das Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_komm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assoziativit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts Weiteres spezifizierst, wird LEAN die erste dieser\nStellen heraussuchen. Wenn du zum Beispiel in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoz,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assoziativit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoz a c b,`.\n", "$a+b+c=a+c+b$\n", "end N -- hide", "Addition - Extras", "Die succ Abbildung ist kein Homomorphismus", "import natnum.add -- hide\n", "import game.Addition.level_7 --hide\n", "namespace N -- hide\n", "F\u00fcr zwei Mengen mit Verkn\u00fcpfung $(M, $\u2217$), (N, $\u22c6$)$ ist eine Abbildung $f: M $\u2192$ N$\nein Homomorphismus, falls $f(m_1)$ \u22c6 $f(m_2) = f(m_1$ \u2217 $m_2)$ f\u00fcr alle $m_1, m_2$ in M.\n\nDie Abbildung `succ` ist eine Abbildung `succ`$: \\mathbb{N}$ \u2192 $\\mathbb{N}$. Wir haben\nauf der Menge der nat\u00fcrlichen Zahlen die Addition als Verkn\u00fcpfung definiert. Wir werden\nnun sehen, dass diese Abbildung kein Homomorphismus bez\u00fcglich der Addition ist.\n", "`succ`$(a) +$ `succ`$(b) =$ `succ`$(a + b) + 1$\n", "end N -- hide", "Multiplikation", "Die Multiplikation", "import natnum.mul -- hide\n", "import game.Addition_Extra.level_1 --hide\n", "namespace N -- hide\n", "a * 0 = 0\n", "a * succ(b) = a*d+a\n", "Man kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n", "Definition: <br>\n`def mul : N \u2192 N \u2192 N` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : N) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : N) : a * (succ d) = a * d + a := rfl`\n", "Klicke hier, um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt.\n", "$0*a=0$\n", "end N -- hide", "Multiplikation mit dem Nachfolger - von links", "import natnum.mul -- hide\n", "import game.Multiplikation.level_1 --hide\n", "namespace N -- hide\n", "## Anleitung\nfalls du in der zu beweisenden Aussage einen Befehl (z.B. `rw add_zero,`) mehrmals\nanwenden kannst, dann wird `{repeat {\u2b1d,},` den Befehl so oft ausf\u00fchren, bis es\nkeine Instanz mehr gibt, an der der Befehl ausgef\u00fchrt werden kann.\n## Beispiel\nBei folgendem Zustand:\n```\na b : N\n\u22a2 a + zero + b = a + (b + zero)\n```\nwird `{repeat {rw add_zero,},` zweimal `add_zero` anwenden und\nsomit das Ziel zu `\u22a2 a + b = a + b ` umformen und damit\nl\u00f6sen.\n", "Manchmal m\u00f6chtest du einen Befehl mehrmals hintereinander ausf\u00fchren. Wenn du dir\nzum Beispiel den Induktionsanfang dieses Levels anschaust, musst du zeigen, dass\n`a.succ * zero = a * zero + zero`, du k\u00f6nntest damit anfangen, \u00fcberall wo mit\n$0$ multipliziert wird `rw mul_zero,` anzuwenden. Anstatt den Befehl zweimal\nauszuschreiben, kannst du `{repeat {rw mul_zero,},` anwenden. Dann wird LEAN den\nBefehl `rw mul_zero,` so oft ausf\u00fchren, bis es keine Instanz der Form `a+zero` gibt.\n", "`succ`$(a) * b = a * b + b$\n", "end N -- hide", "Kommutativit\u00e4t der Multiplikation", "import natnum.mul -- hide\n", "import game.Multiplikation.level_2 -- hide\n", "namespace N -- hide\n", "Die Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t zu zeigen!\n", "a * b = b * a\n", "end N -- hide\n", "Wenn du dir den Beweis der Kommutativit\u00e4t der Addition anschaust und dort\ndas \u00fcberall \"add\" mit \"mul\" ersetzt, hast du einen g\u00fcltigen Beweis f\u00fcr\ndie Kommutativit\u00e4t der Multiplikation!\n", "Kommen dir die Schritte in diesem Beweis bekannt vor?", "Das Distributivgesetz", "import natnum.mul -- hide\n", "import game.Multiplikation.level_3 -- hide\n", "namespace N -- hide\n", "Das Distributivgesetz gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen, in denen\nAddition und Multiplikation vorkommen.\n", "$c * (a + b) = c * a + c * b$\n", "end N -- hide", "Assoziativit\u00e4t der Multiplikation", "import natnum.mul -- hide\n", "import game.Multiplikation.level_4 -- hide\n", "namespace N -- hide\n", "\n\n\n", "$(a * b) * c = a * (b * c)$\n", "end N -- hide\n", "Nein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetz. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n", "Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?", "Multiplikation - Extras", "Multiplikation mit 1", "import natnum.mul -- hide\n", "import game.Multiplikation.level_5 -- hide\n", "namespace N -- hide\n", "\n", "$a * 1 = a$\n", "end N -- hide", "Multiplikation mit 1 - von links", "import natnum.mul -- hide\n", "import game.Multiplikation_Extra.level_1 -- hide\n", "namespace N -- hide\n", "Du hast zwei Optionen f\u00fcr dieses Level. Du kannst mit Induktion starten,\noder du k\u00f6nntest ausnutzen, dass wir gezeigt haben, dass die Multiplikation\nkommutativ ist! \n", "1 * a = a\n", "end N -- hide", "Distributivgesetz - von links", "import natnum.mul -- hide\n", "import game.Multiplikation_Extra.level_2 -- hide\n", "namespace N -- hide\n", "Wir haben das Distributivgesetz gezeigt, wir k\u00f6nnten es aber manchmal auch von\nlinks gebrauchen. Um uns in diesen F\u00e4llen Schreibarbeit zu sparen, zeigen wir hier,\ndass es auch von links gilt. Auch hier kannst du deinen Beweis \u00fcber Induktion f\u00fchren\noder Kommutativit\u00e4t nutzen. Kannst du beide Wege coden?\n", "$(a + b) * c = a * c + b * c$\n", "end N -- hide", "Kommutativit\u00e4t der linken Faktoren", "import natnum.mul -- hide\n", "import game.Multiplikation_Extra.level_3 -- hide\n", "namespace N -- hide\n", "Dieses Level erinnert dich vielleicht an den Beweis von `add_right_komm`. Es geht wieder darum, die\nKommutativit\u00e4t von zwei Faktoren zu zeigen, die in der Operatorrangfolge nicht als Erstes miteinander\nverkn\u00fcpft werden.\n", "a * (b * c) = b * (a * c)\n", "end N -- hide", "Potenzen", "Die Potenzierung", "import natnum.pow -- hide\n", "import game.Multiplikation_Extra.level_4 -- hide\n", "namespace N -- hide\n", "a ^ 0 = 1\n", "a ^ succ(b) = a^b*a\n", "Man kann auch die Potenzierung einer nat\u00fcrlichen Zahl mit einer anderen \nrekursiv anhand der Peano-Axiome definieren.\n- F\u00fcr $m \\in \\mathbb{N}$ sei $m^0=1$\n- F\u00fcr $m,n \\in \\mathbb{N}$ sei $m^{(succ(n))} = m^n*m$\n\nNach dem Prinzip der Induktion ist dann die Potenzierung f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Potenzierung definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `pow_zero` und `pow_succ`.\n", "Definition: <br>\n`def pow : N \u2192 N \u2192 N` <br>\n`| m zero := one` <br>\n`| m (succ n) := pow m n * m` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma pow_zero (m : N) : m ^ (zero : N) = one := rfl` <br>\n`lemma pow_succ (m n : N) : m ^ (succ n) = m ^ n * m := rfl`\n", "Klicke hier, um die Definition der Potenzierung der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass nach Definition gilt, dass $0^0=1$.\n", "$0^0=1$\n", "end N -- hide", "0 hoch etwas ergibt 0", "import natnum.pow -- hide\n", "import game.Potenzen.level_1 -- hide\n", "namespace N -- hide\n", "\nIn diesem Level zeigen wir, dass $0$ hoch jedem Nachfolger einer nat\u00fcrlichen Zahl\n$0$ ergibt.\n\n", "In den Peano-Axiomen steht, dass $0$ nicht der Nachfolger einer Zahl ist. Deswegen\nzeigen wir hier $0^{(succ(a))}=0$ und nicht $0^a=0$. Wir schlie\u00dfen so die $0$ aus.\n", "Wieso folgt daraus nicht $0^0=0$, was ein Widerspruch zu Level 1 ist?", "$0^{(succ(a))}=0$\n", "end N -- hide", "Hoch $1$ nehmen", "import natnum.pow -- hide\n", "import game.Potenzen.level_2 -- hide\n", "namespace N -- hide\n", "\n\n\n", "$a^1 = a$\n", "end N -- hide", "$1$ hoch etwas", "import natnum.pow -- hide\n", "import game.Potenzen.level_3 -- hide\n", "namespace N -- hide\n", "\n\n\n", "$1^a=1$\n", "end N -- hide", "Potenzieren als Homomorphismus $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$", "import natnum.pow -- hide\n", "import game.Potenzen.level_4 -- hide\n", "namespace N -- hide\n", "Wenn wir das Potenzieren als Abbildung $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ein Homomorphismus, da $a^{b + c} = a^b * a^c$. Dies \nist eines der Potenzgesetze.\n", "$a^{b + c} = a^b * a^c$\n", "end N -- hide", "Potenzieren als Homomorphismus $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$", "import natnum.pow -- hide\n", "import game.Potenzen.level_5 -- hide\n", "namespace N -- hide\n", "Wenn wir das Potenzieren als Abbildung $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ebenfalls ein Homomorphismus, da $(a * b)^c = a^c * b^c$. \nDies ist ein weiteres der Potenzgesetze.\n\nDas Potenzieren ist also sowohl im ersten als auch im zweiten Argument ein\nHomomorphismus, aber jeweils bez\u00fcglich einer anderen Verkn\u00fcpfung in der Urbildmenge.\n", "$(a * b)^c = a^c * b^c$\n", "end N -- hide", "Potenz einer Potenz", "import natnum.pow -- hide\n", "import game.Potenzen.level_6 -- hide\n", "namespace N -- hide\n", "Es geht weiter mit noch einem Potenzgesetz.\n", "$(a^b)^c = a^{b * c}$\n", "end N -- hide", "Erste Binomische Formel", "import natnum.pow -- hide\n", "import game.Potenzen.level_7 -- hide\n", "namespace N -- hide\n", "two = succ(one)\n", "Du bist auf dem letzten Level angekommen! Mit allem, was wir\nbisher bewiesen haben, k\u00f6nnen wir die erste binomische Formel\nbeweisen. Das wird aber einige Beweisschritte erfordern.\n\nIn diesem Level kommt die zwei zum ersten Mal explizit vor. Anstatt\n`succ(one)` wollen wir einen Namen einf\u00fchren: `two`. Zus\u00e4tzlich m\u00f6chten wir\nbenutzen k\u00f6nnen, dass `two=succ(one)` ist, diese Aussage nennen wir \n`two_eq_succ_one`.\n", "Definition: <br>\n`def two : N := succ(succ(0))` <br>\n\nDieser Eigenschaften wird ein Namen gegeben: <br>\n`theorem two_eq_succ_one : two = succ(succ(zero)) := rfl`\n", "Klicke hier, um die Definition von `two` in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "$(a+b)^2 = a^2+2*a*b+b^2$\n", "end N -- hide"]]}