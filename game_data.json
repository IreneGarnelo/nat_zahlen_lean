{"name": "Die nat\u00fcrlichen Zahlen", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Die nat\u00fcrlichen Zahlen-1.0-library.zip", "introData": {"name": "1", "problemIndex": -1, "objects": [{"type": "text", "content": "2"}]}, "worlds": [{"name": "3", "levels": [{"name": "4", "problemIndex": 8, "objects": [{"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": true}, {"type": "lean", "content": "7", "hidden": true}, {"type": "text", "content": "8"}, {"type": "hint", "content": "9", "title": "10"}, {"type": "text", "content": "11"}, {"type": "hint", "content": "12", "title": "13"}, {"type": "text", "content": "14"}, {"type": "lemma", "text": "15", "lean": "lemma succ_succ (a b : natnum) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\n", "sideBar": true, "firstProofLineNumber": 84, "lastProofLineNumber": 84, "textBefore": "-- Level name : Die Peano Axiome\n\n-- namespace nat -- hide \n\nimport natnum.definition -- hide\nnamespace natnum -- hide\n\n/-\nDie nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN: `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N})$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\n-/\n\n/- Hint : Wieso brauchen wir hier die Abbildung `succ` um den Nachfolger einer Zahl $n$ zu beschreiben anstatt den Ausdruck n+1 zu verwenden?\nWir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n-/\n\n/-\nAus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt Zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen und nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nnatnum arbeiten, die genau nach den Axiomen von Peano definiert ist.\n-/\n\n/- Hint : Klicke hier um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`inductive natnum` \u2192 $A_4$ <br>\n`| zero : natnum` \u2192 $A_1$ <br>\n`| succ (n : natnum) : natnum` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : natnum} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : natnum) : (zero : natnum) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n-/\n\n/-\nAls erstes muss man das Lemma definieren, dass man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nTODO: LEAN schreibt auch succ(a) = a.succ\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinwiesen, das noch etwas zu tun ist. L\u00f6sche als\nerstes das `sorry` um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehlt. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehts, \u00fcberpr\u00fcfen deinen Code auf fehlende Kommatas.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisch Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen.\n-/\n\n/- Lemma\nFalls `succ`$(a) = b$ dann `succ`$($`succ`$(a)) = $`succ`$(b)$\n-/\nlemma succ_succ (a b : natnum) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\nbegin\n", "proof": "rw h,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 1, "editorText": "sorry", "lineOffset": 83, "name": "succ_succ", "statement": "(a b : natnum) (h : succ(a) = b): succ(succ(a)) = succ(b)"}, {"type": "lean", "content": "16", "hidden": true}]}, {"name": "17", "problemIndex": 4, "objects": [{"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "lemma", "text": "22", "lean": "lemma succ_succ (a b c : natnum) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 30, "textBefore": "-- Level name : Die Peano Axiome - Teil 2\n\n-- namespace nat -- hide \n\nimport natnum.definition -- hide\nnamespace natnum -- hide\n\n/-\nIm diesen Level passiert nicht viel. Es dient eher zur \u00dcbung von dem gelerntem in\nLevel 1.\n\nWir werden aber auch die Gelegenheit nutzen, um uns den `rw` Befehl nochmal\nanzuschauen. Wir haben gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetztz. Aber wie\nkann man jedes `b` durch ein `a` ersetzten? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg?\n-/\n\n/- Lemma\nFalls `succ`$(a) = b$ und `succ`$(b)= c$ dann `succ`$($`succ`$(a)) = c$\n-/\nlemma succ_succ (a b c : natnum) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\nbegin\n", "proof": "rw h,\nrw g,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide\n\n/- Hint : Brauchst du Hilfe um einen zweiten Weg zu finden?\nIn der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n-/", "height": 2, "editorText": "sorry", "lineOffset": 28, "name": "succ_succ", "statement": "(a b c : natnum) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c"}, {"type": "lean", "content": "23", "hidden": true}, {"type": "hint", "content": "24", "title": "25"}]}]}, {"name": "26", "levels": [{"name": "27", "problemIndex": 6, "objects": [{"type": "lean", "content": "28", "hidden": true}, {"type": "lean", "content": "29", "hidden": true}, {"type": "lean", "content": "30", "hidden": true}, {"type": "text", "content": "31"}, {"type": "hint", "content": "32", "title": "33"}, {"type": "text", "content": "34"}, {"type": "lemma", "text": "35", "lean": "lemma add_succ_zero (a : natnum) : a + succ(zero) = succ(a) :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 44, "textBefore": "-- Level name : Die Addition\n\nimport natnum.add -- hide\nimport game.Peano.level_1 --hide\nnamespace natnum -- hide\n\n/-\nMan kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n-/\n\n/- Hint : Klicke hier um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def add : natnum \u2192 natnum \u2192 natnum` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : natnum) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : natnum) : m + succ n = succ (m + n) := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht Formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\n-/\n\n/- Lemma\n$a+$`succ`$(0)=$`succ`$(a)$\n-/\nlemma add_succ_zero (a : natnum) : a + succ(zero) = succ(a) :=\nbegin\n", "proof": "  rw add_succ,\n  rw add_zero,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 2, "editorText": "sorry", "lineOffset": 42, "name": "add_succ_zero", "statement": "(a : natnum) : a + succ(zero) = succ(a)"}, {"type": "lean", "content": "36", "hidden": true}]}, {"name": "37", "problemIndex": 6, "objects": [{"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": true}, {"type": "text", "content": "41"}, {"type": "hint", "content": "42", "title": "43"}, {"type": "text", "content": "44"}, {"type": "lemma", "text": "45", "lean": "lemma succ_eq_add_one (a : natnum) : succ(a) = a + one :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 29, "textBefore": "-- Level name : Die nat\u00fcrliche Zahl 1\n\nimport natnum.add -- hide\nimport game.Addition.level_1 --hide\nnamespace natnum -- hide\n\n/-\nAus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n-/\n\n/- Hint : Klicke hier um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`def one : natnum := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n-/\n\n/- \nNun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. \n-/\n\n/- Lemma\n`succ`$(a) = a + 1$\n-/\nlemma succ_eq_add_one (a : natnum) : succ(a) = a + one :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw add_succ,\nrw add_zero,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 3, "editorText": "sorry", "lineOffset": 26, "name": "succ_eq_add_one", "statement": "(a : natnum) : succ(a) = a + one"}, {"type": "lean", "content": "46", "hidden": true}]}, {"name": "47", "problemIndex": 4, "objects": [{"type": "lean", "content": "48", "hidden": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}, {"type": "lemma", "text": "52", "lean": "lemma zero_add (a : natnum) : zero + a = a :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 39, "textBefore": "-- Level name : Addition mit 0 - von links\n\nimport natnum.add -- hide\nimport game.Addition.level_2 --hide\nnamespace natnum -- hide\n\n/-\nNach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir den `induction` Befehl in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\naufrufen. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen.\n-/\n\n/- Lemma\n$0+a=a$\n-/\nlemma zero_add (a : natnum) : zero + a = a :=\nbegin\n", "proof": "  induction a with d hd,\n  {rw add_zero,},\n  {rw add_succ,\n  rw hd,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 4, "editorText": "sorry", "lineOffset": 35, "name": "zero_add", "statement": "(a : natnum) : zero + a = a"}, {"type": "lean", "content": "53", "hidden": true}]}, {"name": "54", "problemIndex": 6, "objects": [{"type": "lean", "content": "55", "hidden": true}, {"type": "lean", "content": "56", "hidden": true}, {"type": "lean", "content": "57", "hidden": true}, {"type": "text", "content": "58"}, {"type": "hint", "content": "59", "title": "60"}, {"type": "text", "content": "61"}, {"type": "lemma", "text": "62", "lean": "lemma add_assoz (a b c : natnum) : (a + b) + c = a + (b + c) :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 34, "textBefore": "-- Level name : Assoziativit\u00e4t der Addition\n\nimport natnum.add -- hide\nimport game.Addition.level_3 --hide\nnamespace natnum -- hide\n\n/-\nNun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. \n-/\n\n/- Hint : \u00dcber welcher der drei Variablen ist ein Induktionsbeweis am sinnvollsten?\nWir haben die Addition mit Rekursion auf die rechte Variable definiert,\nes ist also sinnvoll bei dem Imduktionsbeweis \u00fcber die Variable\n$c$ zu induzieren.\n-/\n\n/-\nNoch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n-/\n\n/- Lemma\n$(a + b) + c = a + (b + c)$\n-/\nlemma add_assoz (a b c : natnum) : (a + b) + c = a + (b + c) :=\nbegin\n", "proof": "  induction c with d hd,\n  {rw add_zero,\n  rw add_zero,},\n  {rw add_succ (a+b) d,\n  rw add_succ,\n  rw add_succ,\n  rw hd,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 7, "editorText": "sorry", "lineOffset": 27, "name": "add_assoz", "statement": "(a b c : natnum) : (a + b) + c = a + (b + c)"}, {"type": "lean", "content": "63", "hidden": true}]}, {"name": "64", "problemIndex": 4, "objects": [{"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "lean", "content": "67", "hidden": true}, {"type": "text", "content": "68"}, {"type": "lemma", "text": "69", "lean": "lemma succ_add (a b: natnum) : succ(a) + b = succ(a + b) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 23, "textBefore": "-- Level name : Addition mit dem Nachfolger - von links\n\nimport natnum.add -- hide\nimport game.Addition.level_4 --hide\nnamespace natnum -- hide\n\n/-\nGenauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n-/\n\n/- Lemma\n`succ`$(a)+b = $`succ`$(a+b)$\n-/\nlemma succ_add (a b: natnum) : succ(a) + b = succ(a + b) :=\nbegin\n", "proof": "  induction b with d hd,\n  {rw add_zero,\n  rw add_zero,},\n  {rw add_succ,\n  rw hd,\n  rw add_succ,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 6, "editorText": "sorry", "lineOffset": 17, "name": "succ_add", "statement": "(a b: natnum) : succ(a) + b = succ(a + b)"}, {"type": "lean", "content": "70", "hidden": true}]}, {"name": "71", "problemIndex": 4, "objects": [{"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "text", "content": "75"}, {"type": "lemma", "text": "76", "lean": "lemma add_komm (a b: natnum) : a + b = b + a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 21, "textBefore": "-- Level name : Kommutativit\u00e4t der Addition\n\nimport natnum.add -- hide\nimport game.Addition.level_5 --hide\nnamespace natnum -- hide\n\n/-\nEndlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n-/\n\n/- Lemma\na+b=b+a\n-/\nlemma add_komm (a b: natnum) : a + b = b + a :=\nbegin\n", "proof": "  induction b with d hd,\n  {rw add_zero,\n  rw zero_add,},\n  {rw add_succ,\n  rw hd,\n  rw succ_add,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 6, "editorText": "sorry", "lineOffset": 15, "name": "add_komm", "statement": "(a b: natnum) : a + b = b + a"}, {"type": "lean", "content": "77", "hidden": true}]}, {"name": "78", "problemIndex": 4, "objects": [{"type": "lean", "content": "79", "hidden": true}, {"type": "lean", "content": "80", "hidden": true}, {"type": "lean", "content": "81", "hidden": true}, {"type": "text", "content": "82"}, {"type": "lemma", "text": "83", "lean": "lemma add_right_komm (a b c: natnum) : a + b + c = a + c + b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 30, "textBefore": "-- Level name : Kommutativit\u00e4t der rechten Summanden\n\nimport natnum.add -- hide\nimport game.Addition.level_6 --hide\nnamespace natnum -- hide\n\n/-\nDas Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_komm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assozitivit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts weiteres spezifizierst, wird LEAN die erste dieser\nStellen raussuchen. Wenn du zum Beispile in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoz,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assozitivit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoz a c b,`.\n-/\n\n/- Lemma\n$a+b+c=a+c+b$\n-/\nlemma add_right_komm (a b c: natnum) : a + b + c = a + c + b :=\nbegin\n", "proof": "rw add_assoz a b c,\nrw add_komm b c,\nrw \u2190 add_assoz a c b,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 3, "editorText": "sorry", "lineOffset": 27, "name": "add_right_komm", "statement": "(a b c: natnum) : a + b + c = a + c + b"}, {"type": "lean", "content": "84", "hidden": true}]}], "parents": [0]}, {"name": "85", "levels": [{"name": "86", "problemIndex": 4, "objects": [{"type": "lean", "content": "87", "hidden": true}, {"type": "lean", "content": "88", "hidden": true}, {"type": "lean", "content": "89", "hidden": true}, {"type": "text", "content": "90"}, {"type": "lemma", "text": "91", "lean": "lemma succ_non_hom (a b: natnum) : succ(a) + succ(b) = succ(a + b) + one :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 23, "textBefore": "-- Level name : Die succ Abbildung ist kein Homomorphismus\n\nimport natnum.add -- hide\nimport game.Addition.level_7 --hide\nnamespace natnum -- hide\n\n/-\nF\u00fcr zwei Mengen mit Verkn\u00fcpfung $(M, $\u2217$), (N, $\u22c6$)$ ist eine Abbildung $f: M $\u2192$ N$\nein Homomorphismus, falls $f(m_1)$ \u22c6 $f(m_2) = f(m_1$ \u2217 $m_2)$ f\u00fcr alle $m_1, m_2$ in M.\n\nDie Abbildung `succ` ist eine Abbildung `succ`$: \\mathbb{N}$ \u2192 $\\mathbb{N}$. Wir haben\nauf der Menge der nat\u00fcrlichen Zahlen die Addition als Verkn\u00fcpfung definiert. Wir werden\nnun sehen, dass diese Abbildung kein Homomorphismus bez\u00fcglich der Addition ist.\n-/\n\n/- Lemma\n`succ`$(a) +$ `succ`$(b) =$ `succ`$(a + b) + 1$\n-/\nlemma succ_non_hom (a b: natnum) : succ(a) + succ(b) = succ(a + b) + one :=\nbegin\n", "proof": "rw add_succ,\nrw succ_eq_add_one (a.succ+b),\nrw succ_add,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 3, "editorText": "sorry", "lineOffset": 20, "name": "succ_non_hom", "statement": "(a b: natnum) : succ(a) + succ(b) = succ(a + b) + one"}, {"type": "lean", "content": "92", "hidden": true}]}], "parents": [1]}, {"name": "93", "levels": [{"name": "94", "problemIndex": 6, "objects": [{"type": "lean", "content": "95", "hidden": true}, {"type": "lean", "content": "96", "hidden": true}, {"type": "lean", "content": "97", "hidden": true}, {"type": "text", "content": "98"}, {"type": "hint", "content": "99", "title": "100"}, {"type": "text", "content": "101"}, {"type": "lemma", "text": "102", "lean": "lemma zero_mul (a: natnum) : zero*a = zero :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 45, "textBefore": "-- Level name : Die Multiplikation\n\nimport natnum.mul -- hide\nimport game.Addition_Extra.level_1 --hide\nnamespace natnum -- hide\n\n/-\nMan kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n-/\n\n/- Hint : Klicke hier um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def mul : natnum \u2192 natnum \u2192 natnum` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : natnum) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : natnum) : a * (succ d) = a * d + a := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt.\n-/\n\n/- Lemma\n$0*a=0$\n-/\nlemma zero_mul (a: natnum) : zero*a = zero :=\nbegin\n", "proof": "induction a with d hd,\n{rw mul_zero,},\n{rw mul_succ,\nrw hd,\nrw add_zero,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 5, "editorText": "sorry", "lineOffset": 40, "name": "zero_mul", "statement": "(a: natnum) : zero*a = zero"}, {"type": "lean", "content": "103", "hidden": true}]}, {"name": "104", "problemIndex": 4, "objects": [{"type": "lean", "content": "105", "hidden": true}, {"type": "lean", "content": "106", "hidden": true}, {"type": "lean", "content": "107", "hidden": true}, {"type": "text", "content": "108"}, {"type": "lemma", "text": "109", "lean": "lemma succ_mul (a b : natnum) : succ(a) * b = a * b + b :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 30, "textBefore": "-- Level name : Multiplikation mit dem Nachfolger - von links\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_1 --hide\nnamespace natnum -- hide\n\n/-\nManchmal m\u00f6chtest du einen Befehl mehrmal hintereinander Ausf\u00fchren. Wenn du dir\nzum Beispiel den Induktionsanfang dieses Levels anschaust, musst du zeigen, dass\n`a.succ * zero = a * zero + zero`, du k\u00f6nntest damit anfangen, \u00fcberall wo mit\n$0$ multipliziert wird `rw mul_zero,` anzuwenden. Anstatt den Befehl zweimal\nauszuschreiben, kannst du `{repeat {rw mul_zero,},` anwenden. Dann wird LEAN den\nBefehl `rw mul_zero,` so oft ausf\u00fchren, bis es keine Instanz der Form `a+zero` gibt.\n-/\n\n/- Lemma\n`succ`$(a) * b = a * b + b$\n-/\nlemma succ_mul (a b : natnum) : succ(a) * b = a * b + b :=\nbegin\n", "proof": "induction b with d hd,\n{repeat {rw mul_zero,},\nrw add_zero,},\n{rw mul_succ,\nrw mul_succ,\nrw hd,\nrw add_succ,\nrw add_succ,\nrw add_right_komm,\n},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 10, "editorText": "sorry", "lineOffset": 20, "name": "succ_mul", "statement": "(a b : natnum) : succ(a) * b = a * b + b"}, {"type": "lean", "content": "110", "hidden": true}]}, {"name": "111", "problemIndex": 4, "objects": [{"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "lean", "content": "114", "hidden": true}, {"type": "text", "content": "115"}, {"type": "lemma", "text": "116", "lean": "lemma mul_komm (a b : natnum) : a * b = b * a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 21, "textBefore": "-- Level name : Kommutativit\u00e4t der Multiplikation\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_2 -- hide\nnamespace natnum -- hide\n\n/- \nDie Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t zu zeigen!\n-/\n\n/- Lemma\na * b = b * a\n-/\nlemma mul_komm (a b : natnum) : a * b = b * a :=\nbegin\n", "proof": "induction b with d hd,\n{rw mul_zero,\nrw zero_mul,},\n{rw mul_succ,\nrw hd,\nrw succ_mul,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide\n\n/- Hint :  Kommen dir die Schritte in diesem Beweis bekannt vor?\nWenn du dir den Beweis der Kommutativit\u00e4t der Addition anschaust und dort\ndas \u00fcberall \"add\" mit \"mul\" ersetzt, hast du einen g\u00fcltigen Beweis f\u00fcr\nDie Kommutativit\u00e4t der Multiplikation!\n-/", "height": 6, "editorText": "sorry", "lineOffset": 15, "name": "mul_komm", "statement": "(a b : natnum) : a * b = b * a"}, {"type": "lean", "content": "117", "hidden": true}, {"type": "hint", "content": "118", "title": "119"}]}, {"name": "120", "problemIndex": 4, "objects": [{"type": "lean", "content": "121", "hidden": true}, {"type": "lean", "content": "122", "hidden": true}, {"type": "lean", "content": "123", "hidden": true}, {"type": "text", "content": "124"}, {"type": "lemma", "text": "125", "lean": "lemma distr (a b c : natnum) : c * (a + b) = c * a + c * b :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 25, "textBefore": "-- Level name : Das Distributivgesetz\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_3 -- hide\nnamespace natnum -- hide\n\n/-\nDas Distributivgesetzt gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen in denen\nAddition und Multiplikation vorkommen.\n-/\n\n/- Lemma\n$c * (a + b) = c * a + c * b$\n-/\nlemma distr (a b c : natnum) : c * (a + b) = c * a + c * b :=\nbegin\n", "proof": "induction b with d hd,\n{rw add_zero,\nrw mul_zero,\nrw add_zero,},\n{rw add_succ,\nrw mul_succ,\nrw hd,\nrw mul_succ,\nrw add_assoz,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 9, "editorText": "sorry", "lineOffset": 16, "name": "distr", "statement": "(a b c : natnum) : c * (a + b) = c * a + c * b"}, {"type": "lean", "content": "126", "hidden": true}]}, {"name": "127", "problemIndex": 4, "objects": [{"type": "lean", "content": "128", "hidden": true}, {"type": "lean", "content": "129", "hidden": true}, {"type": "lean", "content": "130", "hidden": true}, {"type": "text", "content": "131"}, {"type": "lemma", "text": "132", "lean": "lemma mul_assoz (a b c : natnum) : (a * b) * c = a * (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 22, "textBefore": "-- Level name : Assoziativit\u00e4t der Multiplikation\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_4 -- hide\nnamespace natnum -- hide\n\n/-\n\n\n\n-/\n\n/- Lemma\n$(a * b) * c = a * (b * c)$\n-/\nlemma mul_assoz (a b c : natnum) : (a * b) * c = a * (b * c) :=\nbegin\n", "proof": "induction c with d hd,\n{repeat {rw mul_zero,},},\n{repeat{rw mul_succ},\nrw distr,\nrw hd,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide\n\n/- Hint :  Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?\nNein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetzt. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n-/", "height": 5, "editorText": "sorry", "lineOffset": 17, "name": "mul_assoz", "statement": "(a b c : natnum) : (a * b) * c = a * (b * c)"}, {"type": "lean", "content": "133", "hidden": true}, {"type": "hint", "content": "134", "title": "135"}]}], "parents": [1]}, {"name": "136", "levels": [{"name": "137", "problemIndex": 4, "objects": [{"type": "lean", "content": "138", "hidden": true}, {"type": "lean", "content": "139", "hidden": true}, {"type": "lean", "content": "140", "hidden": true}, {"type": "text", "content": "141"}, {"type": "lemma", "text": "142", "lean": "lemma mul_one (a: natnum) : a*one = a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 19, "textBefore": "-- Level name : Multiplikation mit 1\n\nimport natnum.mul -- hide\nimport game.Multiplikation.level_5 -- hide\nnamespace natnum -- hide\n\n/-\n\n-/\n\n/- Lemma\n$a * 1 = a$\n-/\nlemma mul_one (a: natnum) : a*one = a :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw mul_succ,\nrw mul_zero,\nrw zero_add,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 4, "editorText": "sorry", "lineOffset": 15, "name": "mul_one", "statement": "(a: natnum) : a*one = a"}, {"type": "lean", "content": "143", "hidden": true}]}, {"name": "144", "problemIndex": 4, "objects": [{"type": "lean", "content": "145", "hidden": true}, {"type": "lean", "content": "146", "hidden": true}, {"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lemma", "text": "149", "lean": "lemma one_mul (a: natnum) : one*a = a :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 22, "textBefore": "-- Level name : mul_one\n\nimport natnum.mul -- hide\nimport game.Multiplikation_Extra.level_1 -- hide\nnamespace natnum -- hide\n\n/-\nDu hast zwei optionen f\u00fcr dieses Level. Du kannst mit Induktion starten,\noder du k\u00f6nntest ausnutzen, dass wir gezeigt haben, dass die Multiplikation\nKommutativ ist! \n-/\n\n/- Lemma\na * 1 = a\n-/\nlemma one_mul (a: natnum) : one*a = a :=\nbegin\n", "proof": "induction a with d hd,\n{rw mul_zero,},\n{rw mul_succ,\nrw hd,\nrw succ_eq_add_one,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 5, "editorText": "sorry", "lineOffset": 17, "name": "one_mul", "statement": "(a: natnum) : one*a = a"}, {"type": "lean", "content": "150", "hidden": true}]}, {"name": "151", "problemIndex": 4, "objects": [{"type": "lean", "content": "152", "hidden": true}, {"type": "lean", "content": "153", "hidden": true}, {"type": "lean", "content": "154", "hidden": true}, {"type": "text", "content": "155"}, {"type": "lemma", "text": "156", "lean": "lemma add_mul (a b c: natnum) : (a + b) * c = a * c + b * c :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 30, "textBefore": "-- Level name : Distributivgesetz - von liks\n\nimport natnum.mul -- hide\nimport game.Multiplikation_Extra.level_2 -- hide\nnamespace natnum -- hide\n\n/-\nWir haben das Distributivgesetzt gezeigt, wir k\u00f6nnten es aber manchmal auch von\nlinks gebrauchen. Um uns in diesen F\u00e4llen Schreibarbeit zu sparen, zeigen wir hier,\ndass es auch von links gilt. Auch hier kannst du deinen Beweis \u00fcber Induktion f\u00fchren\noder Kommutativit\u00e4t ausnutzen. Kannst du beide Wege coden?\n-/\n\n/- Lemma\n$(a + b) * c = a * c + b * c$\n-/\nlemma add_mul (a b c: natnum) : (a + b) * c = a * c + b * c :=\nbegin\n", "proof": "induction c with d hd,\n{repeat {rw mul_zero},\nrw add_zero,},\n\n{rw mul_succ,\nrw hd,\nrepeat {rw mul_succ},\nrw add_assoz (a*d) (b*d) (a + b),\nrw \u2190 add_assoz (b*d) a b,\nrw add_komm (b*d) a,\nrw add_assoz a (b*d) b,\nrw \u2190 add_assoz (a*d) a (b * d + b),},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 12, "editorText": "sorry", "lineOffset": 18, "name": "add_mul", "statement": "(a b c: natnum) : (a + b) * c = a * c + b * c"}, {"type": "lean", "content": "157", "hidden": true}]}, {"name": "158", "problemIndex": 4, "objects": [{"type": "lean", "content": "159", "hidden": true}, {"type": "lean", "content": "160", "hidden": true}, {"type": "lean", "content": "161", "hidden": true}, {"type": "text", "content": "162"}, {"type": "lemma", "text": "163", "lean": "lemma mul_left_comm (a b c : natnum) : a * (b * c) = b * (a * c) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 20, "textBefore": "-- Level name : Kommutativit\u00e4t der linken Faktoren\n\nimport natnum.mul -- hide\nimport game.Multiplikation_Extra.level_3 -- hide\nnamespace natnum -- hide\n\n/-\nTODO\n\n\n-/\n\n/- Lemma\na * 1 = a\n-/\nlemma mul_left_comm (a b c : natnum) : a * (b * c) = b * (a * c) :=\nbegin\n", "proof": "rw \u2190 mul_assoz b a c,\nrw mul_komm b a,\nrw mul_assoz a b c,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 3, "editorText": "sorry", "lineOffset": 17, "name": "mul_left_comm", "statement": "(a b c : natnum) : a * (b * c) = b * (a * c)"}, {"type": "lean", "content": "164", "hidden": true}]}], "parents": [3]}, {"name": "165", "levels": [{"name": "166", "problemIndex": 6, "objects": [{"type": "lean", "content": "167", "hidden": true}, {"type": "lean", "content": "168", "hidden": true}, {"type": "lean", "content": "169", "hidden": true}, {"type": "text", "content": "170"}, {"type": "hint", "content": "171", "title": "172"}, {"type": "text", "content": "173"}, {"type": "lemma", "text": "174", "lean": "lemma zero_pow_zero : (zero) ^ (zero) = one :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 40, "textBefore": "-- Level name : Die Potenzierung\n\nimport natnum.pow -- hide\nimport game.Multiplikation_Extra.level_4 -- hide\nnamespace natnum -- hide\n\n/-\nMan kann auch die Potenzierung einer nat\u00fcrlichen Zahlen mit einer anderen \nrekursiv anhand der Peano-Axiome definieren.\n- F\u00fcr $m \\in \\mathbb{N}$ sei $m^0=1$\n- F\u00fcr $m,n \\in \\mathbb{N}$ sei $m^{(succ(n))} = m^n*m$\n\nNach dem Prinzip der Induktion ist dann die Potenzierung f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `pow_zero` und `pow_succ`.\n-/\n\n/- Hint : Klicke hier um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def pow : natnum \u2192 natnum \u2192 natnum` <br>\n`| m zero := one` <br>\n`| m (succ n) := pow m n * m` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma pow_zero (m : natnum) : m ^ (zero : natnum) = one := rfl` <br>\n`lemma pow_succ (m n : natnum) : m ^ (succ n) = m ^ n * m := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass nach Definition gilt, dass $0^0=1$.\n-/\n\n/- Lemma\n$0^0=1$\n-/\nlemma zero_pow_zero : (zero) ^ (zero) = one :=\nbegin\n", "proof": "rw pow_zero,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 1, "editorText": "sorry", "lineOffset": 39, "name": "zero_pow_zero", "statement": "(zero) ^ (zero) = one"}, {"type": "lean", "content": "175", "hidden": true}]}, {"name": "176", "problemIndex": 5, "objects": [{"type": "lean", "content": "177", "hidden": true}, {"type": "lean", "content": "178", "hidden": true}, {"type": "lean", "content": "179", "hidden": true}, {"type": "text", "content": "180"}, {"type": "hint", "content": "181", "title": "182"}, {"type": "lemma", "text": "183", "lean": "lemma zero_pow_succ (a : natnum) : (zero) ^ (succ(a)) = zero :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 25, "textBefore": "-- Level name : 0 hoch etwas ergibt 0\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_1 -- hide\nnamespace natnum -- hide\n\n/-\n\nIn diesem Level zeigen wir, dass $0$ hoch jedem Nachfolger einer nat\u00fcrlichen Zahl\n$0$ ergibt.\n\n-/\n\n/- Hint :  Wieso folgt daraus nicht $0^0=0$, was ein Widerspruch zu level 1 ist?\nIn den Peano Axiomen steht, dass $0$ nicht der Nachfolger einer Zahl ist. Deswegen\nzeigen wir hier $0^{(succ(a))}=0$ und nicht $0^a=0$. Wir schlie\u00dfen so die $0$ aus.\n-/\n\n/- Lemma\n$0^{(succ(a))}=0$\n-/\nlemma zero_pow_succ (a : natnum) : (zero) ^ (succ(a)) = zero :=\nbegin\n", "proof": "rw pow_succ,\nrw mul_zero,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 2, "editorText": "sorry", "lineOffset": 23, "name": "zero_pow_succ", "statement": "(a : natnum) : (zero) ^ (succ(a)) = zero"}, {"type": "lean", "content": "184", "hidden": true}]}, {"name": "185", "problemIndex": 4, "objects": [{"type": "lean", "content": "186", "hidden": true}, {"type": "lean", "content": "187", "hidden": true}, {"type": "lean", "content": "188", "hidden": true}, {"type": "text", "content": "189"}, {"type": "lemma", "text": "190", "lean": "lemma pow_one (a : natnum) : (a) ^ (one) = a :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 21, "textBefore": "-- Level name : Hoch $1$ nehmen\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_2 -- hide\nnamespace natnum -- hide\n\n/-\n\n\n\n-/\n\n/- Lemma\n$a^1 = a$\n-/\nlemma pow_one (a : natnum) : (a) ^ (one) = a :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw pow_succ,\nrw pow_zero,\nrw one_mul,", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 4, "editorText": "sorry", "lineOffset": 17, "name": "pow_one", "statement": "(a : natnum) : (a) ^ (one) = a"}, {"type": "lean", "content": "191", "hidden": true}]}, {"name": "192", "problemIndex": 4, "objects": [{"type": "lean", "content": "193", "hidden": true}, {"type": "lean", "content": "194", "hidden": true}, {"type": "lean", "content": "195", "hidden": true}, {"type": "text", "content": "196"}, {"type": "lemma", "text": "197", "lean": "lemma one_pow (a : natnum) : (one) ^ (a) = one :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 22, "textBefore": "-- Level name : $1$ hoch etwas\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_3 -- hide\nnamespace natnum -- hide\n\n/-\n\n\n\n-/\n\n/- Lemma\n$1^a=1$\n-/\nlemma one_pow (a : natnum) : (one) ^ (a) = one :=\nbegin\n", "proof": "induction a with d hd,\n{rw pow_zero,},\n{rw pow_succ,\nrw mul_one,\nrw hd,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 5, "editorText": "sorry", "lineOffset": 17, "name": "one_pow", "statement": "(a : natnum) : (one) ^ (a) = one"}, {"type": "lean", "content": "198", "hidden": true}]}, {"name": "199", "problemIndex": 4, "objects": [{"type": "lean", "content": "200", "hidden": true}, {"type": "lean", "content": "201", "hidden": true}, {"type": "lean", "content": "202", "hidden": true}, {"type": "text", "content": "203"}, {"type": "lemma", "text": "204", "lean": "lemma pow_add (a b c : natnum) : a ^ (b + c) = a ^ b * a ^ c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 27, "textBefore": "-- Level name : Potenzieren als Homomorphismus $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_4 -- hide\nnamespace natnum -- hide\n\n/-\nWenn wir das Potenzieren als Abbildung $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ein Homomorphismus, da $a^{b + c} = a^b * a^c$. Dies \nist eines der Potenzgesetzte.\n-/\n\n/- Lemma\n$a^{b + c} = a^b * a^c$\n-/\nlemma pow_add (a b c : natnum) : a ^ (b + c) = a ^ b * a ^ c :=\nbegin\n", "proof": "induction c with d hd,\n{rw add_zero,\nrw pow_zero,\nrw mul_one,},\n{rw add_succ,\nrepeat{rw pow_succ},\nrw hd,\nrw \u2190 mul_assoz (a^b) (a^d) a,\n},\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 10, "editorText": "sorry", "lineOffset": 17, "name": "pow_add", "statement": "(a b c : natnum) : a ^ (b + c) = a ^ b * a ^ c"}, {"type": "lean", "content": "205", "hidden": true}]}, {"name": "206", "problemIndex": 4, "objects": [{"type": "lean", "content": "207", "hidden": true}, {"type": "lean", "content": "208", "hidden": true}, {"type": "lean", "content": "209", "hidden": true}, {"type": "text", "content": "210"}, {"type": "lemma", "text": "211", "lean": "lemma mul_pow (a b c : natnum) : (a * b) ^ c = a ^ c * b ^ c :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 31, "textBefore": "-- Level name : Potenzieren als Homomorphismus $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_5 -- hide\nnamespace natnum -- hide\n\n/-\nWenn wir das Potenzieren als Abbildung $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ebenfalls ein Homomorphismus, da $(a * b)^c = a^c * b^c$. \nDies ein weiteres der Potenzgesetzte.\n\nDas Potenzieren ist also sowohl im ersten wie auch im zweiten Argument ein\nHomomorphismus, aber jeweils bez\u00fcglich einer anderen Verkn\u00fcpfung in der Urbildmenge.\n-/\n\n/- Lemma\n$(a * b)^c = a^c * b^c$\n-/\nlemma mul_pow (a b c : natnum) : (a * b) ^ c = a ^ c * b ^ c :=\nbegin\n", "proof": "induction c with d hd,\n{repeat {rw pow_zero},\nrw mul_one,},\n{repeat {rw pow_succ},\nrw hd,\nrw mul_assoz (a ^ d) (b ^ d) (a * b),\nrw \u2190 mul_assoz (b^d) a b,\nrw mul_komm (b^d) a,\nrw mul_assoz a (b^d) b,\nrw \u2190 mul_assoz (a^d) a (b^d*b),\n},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 11, "editorText": "sorry", "lineOffset": 20, "name": "mul_pow", "statement": "(a b c : natnum) : (a * b) ^ c = a ^ c * b ^ c"}, {"type": "lean", "content": "212", "hidden": true}]}, {"name": "213", "problemIndex": 4, "objects": [{"type": "lean", "content": "214", "hidden": true}, {"type": "lean", "content": "215", "hidden": true}, {"type": "lean", "content": "216", "hidden": true}, {"type": "text", "content": "217"}, {"type": "lemma", "text": "218", "lean": "lemma pow_pow (a b c : natnum) : (a ^ b) ^ c = a ^ (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 22, "textBefore": "-- Level name : Potenz einer Potenz\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_6 -- hide\nnamespace natnum -- hide\n\n/-\nEs geht weiter mit noch einem Potenzgesetzt.\n-/\n\n/- Lemma\n(a^b)^c = a^{b * c}\n-/\nlemma pow_pow (a b c : natnum) : (a ^ b) ^ c = a ^ (b * c) :=\nbegin\n", "proof": "induction c with d hd,\n{rw mul_zero,\nrepeat {rw pow_zero},},\n{rw mul_succ,\nrw pow_add,\nrw pow_succ,\nrw hd,},", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 7, "editorText": "sorry", "lineOffset": 15, "name": "pow_pow", "statement": "(a b c : natnum) : (a ^ b) ^ c = a ^ (b * c)"}, {"type": "lean", "content": "219", "hidden": true}]}, {"name": "220", "problemIndex": 5, "objects": [{"type": "lean", "content": "221", "hidden": true}, {"type": "lean", "content": "222", "hidden": true}, {"type": "lean", "content": "223", "hidden": true}, {"type": "text", "content": "224"}, {"type": "hint", "content": "225", "title": "226"}, {"type": "lemma", "text": "227", "lean": "lemma add_squared (a b : natnum) : (a + b) ^ two = a ^ two + two * a * b + b ^ two:=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 44, "textBefore": "-- Level name : Erste Binomische Formel\n\nimport natnum.pow -- hide\nimport game.Potenzen.level_7 -- hide\nnamespace natnum -- hide\n\n/-\nDu bist zu dem letzten Level angekommen! Mit allem was wir\nbisher bewiesen haben k\u00f6nnen wir die erste binomische Formel\nbeweisen. Das wird aber einige Beweisschritte erfordern.\n\nIn diesem Level kommt die zwei zum ersten Mal explizit vor. Anstatt\n`succ(one)` wollen wir einen Namen einf\u00fchren: `two`. Zus\u00e4tzlich m\u00f6chten wir\nbenutzen k\u00f6nnen, dass `two=succ(one)` ist, diese Aussage nennen wir \n`two_eq_succ_one`.\n-/\n\n/- Hint : Klicke hier um die Definition von `two` in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def two : natnum := succ(succ(0))` <br>\n\nDieser Eigenschaften wird ein Namen gegeben: <br>\n`theorem two_eq_succ_one : two = succ(succ(zero)) := rfl`\n-/\n\n/- Lemma\n$(a+b)^2=a^2+2*a*b+b^2$\n-/\nlemma add_squared (a b : natnum) : (a + b) ^ two = a ^ two + two * a * b + b ^ two:=\nbegin\n", "proof": "rw two_eq_succ_one,\nrepeat{rw pow_succ},\nrepeat{rw pow_one},\nrw distr,\nrepeat{rw add_mul},\nrw succ_mul,\nrw \u2190 one_eq_succ_zero,\nrepeat {rw pow_zero,},\nrepeat{rw one_mul,},\nrepeat{rw add_mul,},\nrw mul_komm b a,\nrw add_assoz (a*a) (a*b) (a*b + b*b),\nrw add_assoz (a*a) (a*b+a*b) (b*b),\nrw add_assoz (a*b) (a*b) (b*b),", "proof_hint": "sorry", "textAfter": "\nend\n\nend natnum -- hide", "height": 14, "editorText": "sorry", "lineOffset": 30, "name": "add_squared", "statement": "(a b : natnum) : (a + b) ^ two = a ^ two + two * a * b + b ^ two"}, {"type": "lean", "content": "228", "hidden": true}]}], "parents": [3]}], "texts": [["Die nat\u00fcrlichen Zahlen", "intro", "# Die nat\u00fcrlichen Zahlen\n## Worum geht es in diesem Spiel?\n### Mathematisch \nIn der Schule lernen wir die nat\u00fcrlichen Zahlen kennen und wir lernen, wie \nwir mit ihnen elementare Rechenoperationen durchf\u00fchren. Dabei wird aber nicht \nauf die formale Definition eingegangen, und die Eingenschaften der \nRechenoperationen (zB. die Kommutativit\u00e4t der Addition) werden ohne Begr\u00fcndung\neingef\u00fchrt.\n\nIn dieser Einheit m\u00f6chten wir die Definition der nat\u00fcrlichen Zahlen nach Peano\nbetrachten. Grob gesagt enstehen damit die nat\u00fcrlichen Zahlen aus der 0 zusammen \nmit Rekursion. \u00dcber die Rekursion werden kann dann die Addition, Multiplikation und \nPotenzierung definiert werden. F\u00fcr diese Rechenoperationen werden wir dann die \ngrundlegenden Eigenschaften wie Kommutativit\u00e4t und Assoziativit\u00e4t zeigen.\n\n### Technologisch\nWir werden die Programmiersprache \n<a href=\"https://leanprover-community.github.io/\" target=\"blank\">LEAN</a> kennenlernen.\nLEAN ist ein interaktiver Theorembeweiser. In einem Theorembeweiser kann man\neinen Beweis Schritt f\u00fcr Schritt (in Computersprache) eingeben. Dieser \u00fcberpr\u00fcft\ndann ob der Beweis korrekt ist und kann an jeder Stelle des Beweises Feedback zum\nakuellen Stand des Beweises geben.\n\n\n## Eine kurze Anleitung.\nMit diesem Tool kannst du an dieser Einheit arbeiten. Die Einheit ist in die Kapitel\nPeano, Addition, Multiplikation und Potenzen eingeteilt. Bei der Addition und der \nMultiplikation gibt es zus\u00e4tzliche Kapitel mit Extra-Aufgaben. Jedes Kapitel hat \nmehrere Level. Am besten ist es, wenn du die Kapitel und Level der Reihe nach \nbearbeitest. Eine ausnahme sind die Extra-Kapitel, die nicht erforderlich sind,\num mit dem n\u00e4chsten Kapitel weiterzumachen.\n\nIn jedem Level gibt es als erstes einen Text, der den mathematischen Inhalt und die \nn\u00f6tigen LEAN-Anleitungen des Levels einf\u00fchrt. Darunter ist die zu l\u00f6sende Aufgabe:\nder Beweis eines Satzes, der in LEAN ausgef\u00fchrt werden soll.\n\nDein Fortschritt wird nicht automatisch gespeichert. Um beim n\u00e4chsten Mal dort\nweiterzumachen wo du aufgeh\u00f6rt hast, solltest du vor dem Schlie\u00dfen dieses Fensters\nden \ud83d\udcbe Button \u00fcber dem Spielbaum klicken. Damit wird dein Spielzustand in einer json-Datei gespeichert.\nDiese kannst du beim n\u00e4chsten Mal hochladen indem du den \ud83d\udcdd Button klickst. \n\nViel Spa\u00df beim Coden!\n\n## Du bist mit dem Tool fertig - was nun?\n\nDieses Tool ist eine Anpassung der ersten Levels in dem \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Number Game</a>\nvon Kevin Buzzard. Du kannst dort noch mehr Levels l\u00f6sen und viele andere Befehle\nkennelernen (In unserem Modul haben wir nur `rw` und `induction` verwendet). Die LEAN Version dort\nist etwas \u00e4lter und einige Dinge funktionieren leicht anders, am besten solltest\ndu also die ersten paar Levels wieder l\u00f6sen.\n", "Peano", "Die Peano Axiome", "-- namespace nat -- hide \n", "import natnum.definition -- hide\n", "namespace natnum -- hide\n", "Die nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN: `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N})$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\n", "Wir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n", "Wieso brauchen wir hier die Abbildung `succ` um den Nachfolger einer Zahl $n$ zu beschreiben anstatt den Ausdruck n+1 zu verwenden?", "Aus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt Zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen und nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nnatnum arbeiten, die genau nach den Axiomen von Peano definiert ist.\n", "`inductive natnum` \u2192 $A_4$ <br>\n`| zero : natnum` \u2192 $A_1$ <br>\n`| succ (n : natnum) : natnum` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : natnum} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : natnum) : (zero : natnum) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n", "Klicke hier um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Als erstes muss man das Lemma definieren, dass man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nTODO: LEAN schreibt auch succ(a) = a.succ\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinwiesen, das noch etwas zu tun ist. L\u00f6sche als\nerstes das `sorry` um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehlt. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehts, \u00fcberpr\u00fcfen deinen Code auf fehlende Kommatas.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisch Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen.\n", "Falls `succ`$(a) = b$ dann `succ`$($`succ`$(a)) = $`succ`$(b)$\n", "end natnum -- hide", "Die Peano Axiome - Teil 2", "-- namespace nat -- hide \n", "import natnum.definition -- hide\n", "namespace natnum -- hide\n", "Im diesen Level passiert nicht viel. Es dient eher zur \u00dcbung von dem gelerntem in\nLevel 1.\n\nWir werden aber auch die Gelegenheit nutzen, um uns den `rw` Befehl nochmal\nanzuschauen. Wir haben gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetztz. Aber wie\nkann man jedes `b` durch ein `a` ersetzten? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg?\n", "Falls `succ`$(a) = b$ und `succ`$(b)= c$ dann `succ`$($`succ`$(a)) = c$\n", "end natnum -- hide\n", "In der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n", "Brauchst du Hilfe um einen zweiten Weg zu finden?", "Addition", "Die Addition", "import natnum.add -- hide\n", "import game.Peano.level_1 --hide\n", "namespace natnum -- hide\n", "Man kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n", "Definition: <br>\n`def add : natnum \u2192 natnum \u2192 natnum` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : natnum) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : natnum) : m + succ n = succ (m + n) := rfl`\n", "Klicke hier um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht Formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\n", "$a+$`succ`$(0)=$`succ`$(a)$\n", "end natnum -- hide", "Die nat\u00fcrliche Zahl 1", "import natnum.add -- hide\n", "import game.Addition.level_1 --hide\n", "namespace natnum -- hide\n", "Aus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n", "`def one : natnum := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n", "Klicke hier um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Nun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. \n", "`succ`$(a) = a + 1$\n", "end natnum -- hide", "Addition mit 0 - von links", "import natnum.add -- hide\n", "import game.Addition.level_2 --hide\n", "namespace natnum -- hide\n", "Nach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir den `induction` Befehl in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\naufrufen. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen.\n", "$0+a=a$\n", "end natnum -- hide", "Assoziativit\u00e4t der Addition", "import natnum.add -- hide\n", "import game.Addition.level_3 --hide\n", "namespace natnum -- hide\n", "Nun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. \n", "Wir haben die Addition mit Rekursion auf die rechte Variable definiert,\nes ist also sinnvoll bei dem Imduktionsbeweis \u00fcber die Variable\n$c$ zu induzieren.\n", "\u00dcber welcher der drei Variablen ist ein Induktionsbeweis am sinnvollsten?", "Noch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n", "$(a + b) + c = a + (b + c)$\n", "end natnum -- hide", "Addition mit dem Nachfolger - von links", "import natnum.add -- hide\n", "import game.Addition.level_4 --hide\n", "namespace natnum -- hide\n", "Genauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n", "`succ`$(a)+b = $`succ`$(a+b)$\n", "end natnum -- hide", "Kommutativit\u00e4t der Addition", "import natnum.add -- hide\n", "import game.Addition.level_5 --hide\n", "namespace natnum -- hide\n", "Endlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n", "a+b=b+a\n", "end natnum -- hide", "Kommutativit\u00e4t der rechten Summanden", "import natnum.add -- hide\n", "import game.Addition.level_6 --hide\n", "namespace natnum -- hide\n", "Das Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_komm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assozitivit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts weiteres spezifizierst, wird LEAN die erste dieser\nStellen raussuchen. Wenn du zum Beispile in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoz,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assozitivit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoz a c b,`.\n", "$a+b+c=a+c+b$\n", "end natnum -- hide", "Addition - Extras", "Die succ Abbildung ist kein Homomorphismus", "import natnum.add -- hide\n", "import game.Addition.level_7 --hide\n", "namespace natnum -- hide\n", "F\u00fcr zwei Mengen mit Verkn\u00fcpfung $(M, $\u2217$), (N, $\u22c6$)$ ist eine Abbildung $f: M $\u2192$ N$\nein Homomorphismus, falls $f(m_1)$ \u22c6 $f(m_2) = f(m_1$ \u2217 $m_2)$ f\u00fcr alle $m_1, m_2$ in M.\n\nDie Abbildung `succ` ist eine Abbildung `succ`$: \\mathbb{N}$ \u2192 $\\mathbb{N}$. Wir haben\nauf der Menge der nat\u00fcrlichen Zahlen die Addition als Verkn\u00fcpfung definiert. Wir werden\nnun sehen, dass diese Abbildung kein Homomorphismus bez\u00fcglich der Addition ist.\n", "`succ`$(a) +$ `succ`$(b) =$ `succ`$(a + b) + 1$\n", "end natnum -- hide", "Multiplikation", "Die Multiplikation", "import natnum.mul -- hide\n", "import game.Addition_Extra.level_1 --hide\n", "namespace natnum -- hide\n", "Man kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n", "Definition: <br>\n`def mul : natnum \u2192 natnum \u2192 natnum` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : natnum) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : natnum) : a * (succ d) = a * d + a := rfl`\n", "Klicke hier um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt.\n", "$0*a=0$\n", "end natnum -- hide", "Multiplikation mit dem Nachfolger - von links", "import natnum.mul -- hide\n", "import game.Multiplikation.level_1 --hide\n", "namespace natnum -- hide\n", "Manchmal m\u00f6chtest du einen Befehl mehrmal hintereinander Ausf\u00fchren. Wenn du dir\nzum Beispiel den Induktionsanfang dieses Levels anschaust, musst du zeigen, dass\n`a.succ * zero = a * zero + zero`, du k\u00f6nntest damit anfangen, \u00fcberall wo mit\n$0$ multipliziert wird `rw mul_zero,` anzuwenden. Anstatt den Befehl zweimal\nauszuschreiben, kannst du `{repeat {rw mul_zero,},` anwenden. Dann wird LEAN den\nBefehl `rw mul_zero,` so oft ausf\u00fchren, bis es keine Instanz der Form `a+zero` gibt.\n", "`succ`$(a) * b = a * b + b$\n", "end natnum -- hide", "Kommutativit\u00e4t der Multiplikation", "import natnum.mul -- hide\n", "import game.Multiplikation.level_2 -- hide\n", "namespace natnum -- hide\n", "Die Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t zu zeigen!\n", "a * b = b * a\n", "end natnum -- hide\n", "Wenn du dir den Beweis der Kommutativit\u00e4t der Addition anschaust und dort\ndas \u00fcberall \"add\" mit \"mul\" ersetzt, hast du einen g\u00fcltigen Beweis f\u00fcr\nDie Kommutativit\u00e4t der Multiplikation!\n", "Kommen dir die Schritte in diesem Beweis bekannt vor?", "Das Distributivgesetz", "import natnum.mul -- hide\n", "import game.Multiplikation.level_3 -- hide\n", "namespace natnum -- hide\n", "Das Distributivgesetzt gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen in denen\nAddition und Multiplikation vorkommen.\n", "$c * (a + b) = c * a + c * b$\n", "end natnum -- hide", "Assoziativit\u00e4t der Multiplikation", "import natnum.mul -- hide\n", "import game.Multiplikation.level_4 -- hide\n", "namespace natnum -- hide\n", "\n\n\n", "$(a * b) * c = a * (b * c)$\n", "end natnum -- hide\n", "Nein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetzt. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n", "Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?", "Multiplikation - Extras", "Multiplikation mit 1", "import natnum.mul -- hide\n", "import game.Multiplikation.level_5 -- hide\n", "namespace natnum -- hide\n", "\n", "$a * 1 = a$\n", "end natnum -- hide", "mul_one", "import natnum.mul -- hide\n", "import game.Multiplikation_Extra.level_1 -- hide\n", "namespace natnum -- hide\n", "Du hast zwei optionen f\u00fcr dieses Level. Du kannst mit Induktion starten,\noder du k\u00f6nntest ausnutzen, dass wir gezeigt haben, dass die Multiplikation\nKommutativ ist! \n", "a * 1 = a\n", "end natnum -- hide", "Distributivgesetz - von liks", "import natnum.mul -- hide\n", "import game.Multiplikation_Extra.level_2 -- hide\n", "namespace natnum -- hide\n", "Wir haben das Distributivgesetzt gezeigt, wir k\u00f6nnten es aber manchmal auch von\nlinks gebrauchen. Um uns in diesen F\u00e4llen Schreibarbeit zu sparen, zeigen wir hier,\ndass es auch von links gilt. Auch hier kannst du deinen Beweis \u00fcber Induktion f\u00fchren\noder Kommutativit\u00e4t ausnutzen. Kannst du beide Wege coden?\n", "$(a + b) * c = a * c + b * c$\n", "end natnum -- hide", "Kommutativit\u00e4t der linken Faktoren", "import natnum.mul -- hide\n", "import game.Multiplikation_Extra.level_3 -- hide\n", "namespace natnum -- hide\n", "TODO\n\n\n", "a * 1 = a\n", "end natnum -- hide", "Potenzen", "Die Potenzierung", "import natnum.pow -- hide\n", "import game.Multiplikation_Extra.level_4 -- hide\n", "namespace natnum -- hide\n", "Man kann auch die Potenzierung einer nat\u00fcrlichen Zahlen mit einer anderen \nrekursiv anhand der Peano-Axiome definieren.\n- F\u00fcr $m \\in \\mathbb{N}$ sei $m^0=1$\n- F\u00fcr $m,n \\in \\mathbb{N}$ sei $m^{(succ(n))} = m^n*m$\n\nNach dem Prinzip der Induktion ist dann die Potenzierung f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `pow_zero` und `pow_succ`.\n", "Definition: <br>\n`def pow : natnum \u2192 natnum \u2192 natnum` <br>\n`| m zero := one` <br>\n`| m (succ n) := pow m n * m` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma pow_zero (m : natnum) : m ^ (zero : natnum) = one := rfl` <br>\n`lemma pow_succ (m n : natnum) : m ^ (succ n) = m ^ n * m := rfl`\n", "Klicke hier um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass nach Definition gilt, dass $0^0=1$.\n", "$0^0=1$\n", "end natnum -- hide", "0 hoch etwas ergibt 0", "import natnum.pow -- hide\n", "import game.Potenzen.level_1 -- hide\n", "namespace natnum -- hide\n", "\nIn diesem Level zeigen wir, dass $0$ hoch jedem Nachfolger einer nat\u00fcrlichen Zahl\n$0$ ergibt.\n\n", "In den Peano Axiomen steht, dass $0$ nicht der Nachfolger einer Zahl ist. Deswegen\nzeigen wir hier $0^{(succ(a))}=0$ und nicht $0^a=0$. Wir schlie\u00dfen so die $0$ aus.\n", "Wieso folgt daraus nicht $0^0=0$, was ein Widerspruch zu level 1 ist?", "$0^{(succ(a))}=0$\n", "end natnum -- hide", "Hoch $1$ nehmen", "import natnum.pow -- hide\n", "import game.Potenzen.level_2 -- hide\n", "namespace natnum -- hide\n", "\n\n\n", "$a^1 = a$\n", "end natnum -- hide", "$1$ hoch etwas", "import natnum.pow -- hide\n", "import game.Potenzen.level_3 -- hide\n", "namespace natnum -- hide\n", "\n\n\n", "$1^a=1$\n", "end natnum -- hide", "Potenzieren als Homomorphismus $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$", "import natnum.pow -- hide\n", "import game.Potenzen.level_4 -- hide\n", "namespace natnum -- hide\n", "Wenn wir das Potenzieren als Abbildung $a\u2227\u2b1d: (\\mathbb{N}, +) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ein Homomorphismus, da $a^{b + c} = a^b * a^c$. Dies \nist eines der Potenzgesetzte.\n", "$a^{b + c} = a^b * a^c$\n", "end natnum -- hide", "Potenzieren als Homomorphismus $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$", "import natnum.pow -- hide\n", "import game.Potenzen.level_5 -- hide\n", "namespace natnum -- hide\n", "Wenn wir das Potenzieren als Abbildung $\u2b1d\u2227c: (\\mathbb{N}, *) \u2192 (\\mathbb{N}, *)$\nauffassen, dann ist $\u2227$ ebenfalls ein Homomorphismus, da $(a * b)^c = a^c * b^c$. \nDies ein weiteres der Potenzgesetzte.\n\nDas Potenzieren ist also sowohl im ersten wie auch im zweiten Argument ein\nHomomorphismus, aber jeweils bez\u00fcglich einer anderen Verkn\u00fcpfung in der Urbildmenge.\n", "$(a * b)^c = a^c * b^c$\n", "end natnum -- hide", "Potenz einer Potenz", "import natnum.pow -- hide\n", "import game.Potenzen.level_6 -- hide\n", "namespace natnum -- hide\n", "Es geht weiter mit noch einem Potenzgesetzt.\n", "(a^b)^c = a^{b * c}\n", "end natnum -- hide", "Erste Binomische Formel", "import natnum.pow -- hide\n", "import game.Potenzen.level_7 -- hide\n", "namespace natnum -- hide\n", "Du bist zu dem letzten Level angekommen! Mit allem was wir\nbisher bewiesen haben k\u00f6nnen wir die erste binomische Formel\nbeweisen. Das wird aber einige Beweisschritte erfordern.\n\nIn diesem Level kommt die zwei zum ersten Mal explizit vor. Anstatt\n`succ(one)` wollen wir einen Namen einf\u00fchren: `two`. Zus\u00e4tzlich m\u00f6chten wir\nbenutzen k\u00f6nnen, dass `two=succ(one)` ist, diese Aussage nennen wir \n`two_eq_succ_one`.\n", "Definition: <br>\n`def two : natnum := succ(succ(0))` <br>\n\nDieser Eigenschaften wird ein Namen gegeben: <br>\n`theorem two_eq_succ_one : two = succ(succ(zero)) := rfl`\n", "Klicke hier um die Definition von `two` in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "$(a+b)^2=a^2+2*a*b+b^2$\n", "end natnum -- hide"]]}